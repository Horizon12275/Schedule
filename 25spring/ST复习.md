## 复习

### 路径测试

1. 程序图

   - 程序图是一种有向图，图中的节点表示语句片段，边表示控制流。
   - 如果 i 和 j 是程序图中的节点，从节点 i 到节点 j 存在一条边，当且仅当对应节点 j 的语句片段可以在对应节点 i 的语句片段之后立即执行。

2. DD-路径图（决策到决策）

   - 程序流图是一种有向图，其中的节点表示语句，边表示控制流。
   - 对于给定的程序，可以使用多种不同的程序流图，所有这些程序流图，都可以简化为唯一的 DD-路径图。

3. DD-路径定义

   - DD-路径是程序图中的一条链，使得：
   - 情况 1：由一个节点组成，入度=0。
   - 情况 2：由一个节点组成，出度=0。
   - 情况 3：由一个节点组成，入度 >= 2 或出度 >= 2。
   - 情况 4：由一个节点组成，入度=1 并且出度=1。
   - 情况 5：长度 >=2 的最大链(单入单出的最大序列)。
   - 换言之：DD-路径是程序图中的最小独立路径，不能被包括在其它 DD-路径之中。
   - 应该就是把程序图压缩了路径后的图

4. DD 路径定义:对给定用命令语言编写的一段程序, 其 DD 路径是有向图，其中节点表示程序图的 DD 路径，边表示连续 DD 路径之间的控制流。 换言之，DD 路径是一种压缩图，其中的一个节点（DD 路径），对应程序中的语句片段。

5. 语句覆盖（$C_0$）

   - 使程序中每一可执行语句至少执行一次；
   - 有时候其实设计一个测试用例就可以了

6. DD-路径测试

   - 分支覆盖（$C_1$）：使程序中的每个逻辑判断的取真取假分支至少经历一次；
   - 条件覆盖（$C_{1}p$ ）：所有判断的每种分支（让所有 bool 表达式的条件都满足至少一次）（要细看里面的条件）

7. 多条件覆盖（$C_{mcc}$）

   - 使得每个判断表达式中条件的各种可能组合都至少出现一次；
   - ppt 的例子虽然满足条件组合覆盖，但并不能覆盖程序中的每一条路径，例如路径 acd 就没有执行，因此，多条件覆盖标准仍然是不彻底。

8. 分支/条件覆盖

   - 针对上面的问题引出了另一种覆盖标准—“分支 ／条件覆盖”，它的含义是：执行足够的测试用例，使得分支中每个条件取到各种可能的值，并使每个分支取到各种可能的结果。

9. 路径测试 $C_{\infty}$

   - 路径测试就是设计足够多的测试用例，覆盖被测试对象中的所有可能路径。

10. 循环测试

11. 单循环测试

    - 假设循环次数为 N
    - a. 直接跳过循环
    - b. 循环次数为 1
    - c. 循环次数为 2
    - d. 循环次数为 M，M<N
    - e. 循环次数为 N-1，N，N+1

12. 嵌套循环测试

    - a. 先测试最内部循环，其它循环次数为 1
    - b. 测试第二层循环，其它循环次数为 1，
    - c. 直到最外部循环完成测试

13. 级连循环测试

    - 分别采用单循环测试方法进行测试

14. 不规则循环测试 无法测试 —— 需要重新设计

15. 小结

    - 无论哪种测试覆盖，即使其覆盖率达到百分之百， 都不能保证把所有隐藏的程序欠缺都揭露出来。
    - 提高结构的测试覆盖率只能增强我们对被测软件的 信心，但它绝不是万无一失的。

16. McCabe 圈数（基路径）

    - 基路径的概念与方法
    - 基：借鉴了向量空间的概念，向量空间的基是相互独立的一组向量，基“覆盖”整个向量空间。使得该空间中的任何其它向量都可以用基向量表示。
    - 基路径：程序图中相互独立的一组路径，使得该程序中的所有路径都可以用基路径表示。（类似空间向量的概念）

17. 圈复杂度

    - 是一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的 基本路径数目。

18. 基本路径必须从起始点到终止点的路径。

    - 包含一条其他基本路径不曾用到的边。或至少引入一个新处理语句或者新判断的程序通路。
    - 对于循环而言，基本路径应包含不执行循环和执行一次循环的路径

19. McCabe 圈数（基本路径圈复杂度找法） V（G）计算方法：

    - V（G）=e-n+2p
    - e：DD 路径的边数
    - n：DD 路径的节点数
    - p：联通分量数
    - 任何路径都可以看作是上述的所有基本路径的组合形成的。
    - 其中，加法是一条路径后接一条路径；乘法是路径的重复，而减法则只有数学上去除边的含义，而缺少实际意义。

20. 参考课本说明强连接有向图的计算公式(不满足单入口、单出口条件)。

    - 强连通图是 V（G）=e-n+p
    - 强连通图：每个节点都可以到达其它所有节点，且每个节点都可以被其它所有节点到达。

21. 如何寻找 McCabe 路径？

    - 图的搜索与遍历算法！
    - 深度优先算法
    - 广度优先算法

22. 好处：就是只需要测试基本路径、就相当于能够测试所有的路径

23. 基本复杂度

    - McCabe 在圈复杂度上的工作,在一定意义上,对程序设计的改进要大于对测试的改进。
    - 对于结构化程序设计的程序，可以将 if-thenelse 构造压缩为一个节点。
    - 则三角形程序最终可以压缩为只有一条路径的图！
    - 而对于非结构化程序，必然增加 McCabe 圈的数量。
    - 一般的，一个单元模块的最大复杂度 V（G）<10。

24. 圈复杂度 V 的值等于程序控制流图中线性独立的基本路径的最大数量。

### 数据流测试

1. 数据流测试

   - 数据流测试是从关注程序中数据及其使用的角度，来设计测试用例的。类似一种路径测试覆盖，但关心的是数据变量而不是程序结构。

2. 定义-使用（def-use）测试

   - 定义-使用测试是一种数据流测试，它关注的是程序中变量的定义和使用之间的关系。
   - 定义语句：输入语句、赋值语句、循环控制语句和过程调用语句，即：向内存地址写入值的语句。
   - 使用语句：输出语句、赋值语句、条件语句、循环控制语句和过程调用语句，都是可能的使用语句。但它们不改变变量的值。即：从内存地址读取值的语句。
   - 谓词使用（记做 P-use）：是一个使用语句，它的结果是一个布尔值。（使用节点是一个谓词使用）
   - 计算使用（记做 C-use）：是一个使用语句，它的结果是一个数值。
   - 定义-使用路径（记做 du-path）：
   - 定义-清除路径（记做 dc-path）：是一个从定义语句到使用语句的路径，其中没有其他定义语句。（具有起始和终止节点，使得该路径中没有其它节点是 v 的定义节点。）
   - ppt 上有一个例题

3. 定义-使用路径测试覆盖指标

   - 全定义准则：每个定义节点到一个使用的定义清除路径。
   - 全使用准则：每个定义节点到所有使用节点以及后续节点的定义清除路径。
   - 全谓词使用/部分计算使用准则：每个定义节点到所有谓词使用的定义清除路径，若无谓词使用，至少有一个计算使用的定义清除路径。
   - 全计算使用/部分谓词使用准则：每个定义节点到所有计算使用的定义清除路径，若无计算使用，至少有一个谓词使用的定义清除路径。
   - 全定义-使用路径准则：每个定义节点到所有使用节点以及后续节点的定义清除路径。包括有一次环路和或无环路的路径。

4. 基于程序片的测试

   - 定义：给定一个程序 P 和 P 中的一个变量集合 V，变量集合 V 在语句 n 上的一个片，记做 S（V，n），是 P 中对 V 中的变量值作出贡献的所有语句（编号）的集合。
   - USE（使用）的形式有：谓词使用、计算使用、输出使用、定位使用、迭代使用
   - DEF（定义）的形式有：输入定义、赋值定义
   - 程序片的方法，将程序进行了分段划分。就如佣金问题的 commission 是最终结果，它的计算依赖于 sales 的计算；而 sales 的计算，又依赖于 lockSales、stockSales、barrelSales 的计算；而 lockSales、stockSales、barrelSales 的计算又分别依赖于 totalLocks、totalStocks、totalbarrels 的计算等等。
   - 如果所有变量的定义和使用是正确的，当然程序就是正确的！

5. 测试的效率

   1. 当时间用完时——缺少标准
   2. 当继续测试没有产生新失效时
   3. 当继续测试没有发现新缺陷时
   4. 当无法考虑新测试用例时—原因？
   5. 当回报很小时—基于分析的方法
   6. 当达到所要求的覆盖时—结构化测试的指标
   7. 当所有缺陷都已经清除时—难以实现

6. 漏洞与冗余

   - 如果采用最坏情况测试，测试用例为 53=125 个，能够覆盖全部 11 条路径，但是冗余很多！

7. 用于方法评估的指标

   - 假设功能性测试技术 M 生成 m 个测试用例,并且根据标识被测单元中的 s 个元素的结构性测试指标 S 来跟踪这些测试用例.当执行 m 个测试用例时,会经过 n 个结构性测试单元。
   - 定义：方法 M 关于指标 S 的覆盖是:n 与 s 的比值,记做 C(M,S)。
   - 定义：方法 M 关于指标 S 的冗余是 m 与 s 的比值，记做 R(M,S)
   - 定义：方法 M 关于指标 S 的净冗余是 m 与 n 的比值，记做 NR(M,S)。

### 回归测试(书上没有)

1. Regression Testing（回归测试）

   - 迭代式开发中形成的习惯
   - 一般是在软件的迭代开发中，每次迭代都要做回归测试
   - 一般是用自动化测试工具
   - 可以只测一部分，全测的话效率太低

2. 软件迭代开发过程中，软件的功能和结构都在不断变化。

   - 回归测试是为了验证软件的修改没有引入新的错误。
   - 最直接的是直接跑一遍原来的测试用例，看看是否有新的错误。
   - 但是优化的方法是：只跑那些受影响的测试用例。
   - 受影响的测试用例是指：修改的代码所影响的测试用例，可以降低测试的成本。

3. 测试用例库：

   - 主要是为了存储测试用例，便于后续的回归测试。
   - 有些时候、版本修改之后、会有添加和删除的测试用例。
   - 基线测试用例库 ：当得到⼀个软件的基线版本时，用于 基线版本测试的所有测试用例就形成了基线测试用例库（回归测试在维护基线测试用例库的基础上进行）。

4. 回归测试应该兼顾效率和有效性。

   - 再测试全部用例（再测试全部用例具有最低的遗漏回归错误的风险，但是测试成本最⾼。）
   - 基于风险选择测试（首先运⾏最重要的、关键的和可疑的测试，逐步降低风险值,直⾄满⾜回归测试要求。）
   - 基于操作剖面向选择测试（测试用例是基于软件操作剖面开发的，优先选择那些针对最重要或最频繁使用功能的测试用例。）

5. 回归测试的步骤

   1. 识别出软件中被修改的部分。
   2. 从原基线测试用例库 T 中，排除所有不再适用的测试用 例，确定那些对新的软件版本依然有效的测试用例，其结果是建立⼀个新的基线测试用例库 T0。
   3. 依据⼀定的策略从 T0 中选择测试用例测试被修改的软件。
   4. 如果必要，⽣成新的测试用例集 T1，用于测试 T0 ⽆法充分测试的软件部分。
   5. 用 T1 执⾏修改后的软件。
   6. 第(2)和第(3)步测试，验证修改是否破坏了现有的功能， 第(4)和第(5)步测试验证修改⼯作本身。

6. 有 3 种方法

   - Test selection using execution trace and execution slice（根据执行轨迹和执行切片进行测试选择）
   - Test selection using test minimization（根据测试最小化进行测试选择）
   - Test selection using test prioritization（根据测试优先级进行测试选择）

7. 方法一步骤：根据执行轨迹和执行切片进行测试选择

   - CFG（Control Flow Graph，控制流图）是程序的一个重要表示方法，它将程序的控制流结构以图的形式展现出来。
   - Step 1: Given P and test set T, find the execution trace of P for each test in T. （给定程序 P 和测试集 T，找到 P 在 T 中每个测试的执行轨迹。）
   - Step 2: Extract test vectors from the execution traces for each node in the CFG of P （从 P 的控制流图（CFG）中提取每个节点的测试向量。）
   - Step 3: Construct syntax trees for each node in the CFGs of P and P’. This step can be executed while constructing the CFGs of P and P’. （为 P 和 P’ 的每个节点构建语法树。此步骤可以在构建 P 和 P’ 的 CFG 时执行。）
   - Step 4: Traverse the CFGs and determine the a subset of T appropriate for regression testing of P’. （遍历 CFG 并确定适合 P’ 回归测试的 T 的子集。）

8. test vector 就是以向量的形式表示、每一个测试用例在每一个函数中的的执行轨迹。

9. 回归测试的本质是测试用例的选择、而不是生成新的测试用例

   - 核心的思路：哪里修改了、就选择哪里相关的测试用例。
   - 比如说如果这里 2 部分的代码修改了、那么就选择与这个部分相关的测试用例 t1 和 t3。
   - 核心就是这个表

10. 测试最小化（test minimization）（必考题）

    - 提出了功能覆盖的要求定义
    - 首先需要辨别可测试的实体类型（比如说这里关注的是徐娅选择最小的测试用例集去覆盖所有的 function）（这里也不用关心修改的部分）（也可以选择分支之类的实体）
    - 然后再选择测试用例
    - 也可以根据测试优先级去选择（自己指定测试用例的优先级）

11. 测试最小化流程

    - 步骤 1：选定待分析的可测试实体类型 TE（如前例中的函数），设 P 中共有 k 个此类实体 e₁, e₂,...eₖ。
    - 步骤 2：用测试集 T 执行 P，记录每个测试用例 t 覆盖的实体。
    - 步骤 3：找出 T 的最小子集 T'，确保每个实体至少被 T'中的一个测试覆盖。

12. 例子：这里选择的实体是 basic block（基本块），即程序中的一段连续执行的代码。选择了 t1 + t3 （覆盖了所有的基本块）

### 变异测试

1. Mutation test（变异测试）

   - 是注入错误流进行测试
   - 通过改变程序中的一些内容，让它变成错的，然后测试
   - 是去增强测试的充分性
   - 然后要注入经常犯的错误

2. 如何说明测试的充分性？可以通过覆盖率等指标（分支覆盖等）

3. 测试充分性问题说明：考虑为满足功能需求集 R 编写的程序 P，记为(P, R)，R 包含 n 个需求 R1-Rn。构造含 k 个测试的集合 T 测试 P 是否满足 R 中所有需求，P 对 T 中每个测试执行正确。问题是 T 是否足够好，即 P 是否被充分测试，或 T 是否充分。

4. 测试充分性核心问题：

   - T 是否足够好？
   - P 是否被充分测试？
   - T 是否充分？
   - 需求覆盖（是否所有 R1-Rn 被测试）。
   - 测试质量（是否包含边界条件、异常情况等）。
   - 正确性验证（P 在 T 中所有测试是否表现正确）。

5. 程序突变的定义：

   - 对已通过测试集 T 的程序 P 进行修改得到 P'
   - 观察 P'在 T 中的测试行为
   - P'称为 P 的突变体
   - 若存在测试 t∈T 使 P(t)≠P'(t)，则 t 杀死了 P'（测试用例能够区分）
   - 若原有 T 种无任何此 t，则 P'在测试过程中存活（就是修改了之后通过了，T 不能区分 P 和 P'，T 还不足够）
   - 预期：如果变化了之后、测试用例集不能发生什么错误变化、那么其实本质上是测试用例集不够（或者是和修改没关系）、充分性不足

6. 等价突变体：

   - 就是如果突变的内容是语义上就一样的、那么显然无法通过测试用例集 T 来区分
   - 若输入域中不存在能区分 P 和 P'的测试用例，则 P'等价于 P
   - 等价突变体无法被任何测试发现
   - 非等价且存活的突变体可用于增强 T
   - 通过生成新测试用例杀死存活突变体来改进 T
   - 突变测试是评估测试集充分性的有效方法

7. 突变测试步骤：

   - 步骤 1：创建 P 的突变体集合 M={M1...Mk}，共 k 个突变体 （首先生成变异体，多少个都可以、主要看精力）
   - 步骤 2：对每个突变体 Mi，检查 T 中是否存在 t 使 Mi(t)≠P(t)，若存在，Mi 被杀死并从集合中移除
   - 步骤 3：统计 k1 个被杀死的突变体，(k-k1)个存活的突变体
     - 情况 1：若(k-k1)=0，T 对突变是充分的
     - 情况 2：若(k-k1)>0，计算突变得分 MS=k1/(k-e)（其中 e 为等价突变体数量，且 e≤(k-k1)）
   - 突变体：程序 P 的修改版本
   - 被杀死的突变体：被测试集 T 发现的突变体
   - 存活的突变体：未被 T 发现的突变体
   - 等价突变体：与 P 语义完全相同的突变体

   1. 变异得分(MS)为 1 时的处理：（存活的变异体全是等价变异体 k-e = k1）（等价变异体不会被杀死）
      - 需要使用其他技术或不同的变异体集来增强 T
   2. 变异得分(MS)小于 1 时的处理步骤：
      - 步骤 1：识别存活且不等价于 P 的变异体
      - 步骤 2：为每个存活变异体设计新测试 t 以区分其与 P
      - 步骤 3：若 t 未能区分目标变异体 m，需重新设计测试
      - 步骤 4：成功的 t 可能同时区分多个存活变异体
      - 步骤 5：将成功区分变异体的新测试 t 加入 T，并重新计算变异得分(MS)
      - 步骤 6：重复步骤 2-5，直到所有存活变异体被区分或无法再设计新测试

8. **正确性取决于生成变异体的时候变异体是什么**

   - 这里的测试充分性是和变异体自身相关的（变异体可能不一样）
   - 也和变异体的数量和质量有关
   - 变异测试是已经通过了什么黑盒白盒测试之后、还需要进行进一步测试的时候进行测试 （例子里是加法函数和减法函数）
   - **变异体生成要模拟熟练程序员经常会犯的错误**
   - 如果变异体能存活、那么说明测试用例不充分、那么就需要增加测试用例
   - 测试用例都是为了找错误

9. 例子：加法函数和减法函数

   - 首先生成变异体，可以变运算符、也可以替换变量、或者替换变量为 0 或常数（例子里的变异体显然不是等价变异体）（等价变异体的数量相对是比较少的）
   - 变异体 M 区分不了 即存活、如果能区分、即 Killed
   - 生成完变异体画表格、做测试用例结果分析

10. 区分变异体的三个必要条件：

    - 条件 1（可达性）：测试用例 t 必须执行到变异语句 s
    - 条件 2（传染性）：执行变异语句 s 后，P 和 m 的程序状态不一致
    - 条件 3（传播性）：状态不一致最终导致 P 和 m 的输出不同

11. 等价变异体判定问题：

    - 判断变异体是否与父程序等价是不可判定的问题
    - 无法完全自动化检测等价变异体
    - 等价变异体识别过程：因此、通常需要手动识别，是一个耗时且令人沮丧的过程
    - 典型等价变异体示例（两者功能完全等效）：
    - 程序 p 使用"for(int i=0;i<10;i++)"
    - 变异体 p'使用"for(int i=0;i=10;i+=1)"

12. 变异体的好与坏在于是否能够发现其中的错误

    - 空指针风险、变量混淆、公式错误等

13. First order and higher order（一阶和高阶）（变异体如何生成）

    - 一般只用一阶变异体（用的最多的）
    - 一阶变异体：只考虑单个语句的变异，就是一处修改
    - 高阶变异体：考虑多个语句的组合变异

14. 程序员经常犯小错误、最后的错误经常由小错误（简单错误）的耦合而产生

    - 比如变量的代换
    - 关系运算符和运算的代换（或者括号的添加减少）
    - 加减 1
    - 替换成 0

15. Competent programmer hypothesis (CPH)（熟练能力假设）

    - 假设程序员在编写程序时会犯错误，但不会故意编写错误的代码。
    - 变异体生成的基础假设是程序员在编写代码时会犯错误，但不会故意编写错误的代码。

16. Coupling effect（耦合效应）

    - 由一阶变异体的组合而产生的错误。
    - 耦合效应是指多个小错误的组合可能导致更大的错误。

17. 变异测试适用的阶段：

    - 变异测试经常适用于单元测试阶段，用于增强测试用例。（小单元、对测试用例的要求高的情况下做，提高测试充分性，已经）
    - 变异测试的充分与否与生成的变异体的数量和质量有关。

### 功能性测试

1. 依据（基本要求）：软件的功能需求文档（里的输入输出）

2. 核心：选择合适的输入（本质上是黑盒测试）

3. 边界测试

   - 边界值（边界点上经常会发生软件错误）
   - 边界值测试的取值: 最小值、略高于最小值、正常值、略低于最高值、最高值。（为了达到最小用例能够覆盖所有的情况）
   - 单缺陷假设：失效极少是由 2 个（或更多）缺陷同时发生引起的。（基本上是一个缺陷引起的）
   - N 个变量的测试用例数：4N+1

4. 健壮性测试

   - 除了 5 个边界值，再增加一个略小于最小值（min ）,一个略大于最大值（max+）。
   - 即:要考虑无效值的输入!
   - N 个变量的测试用例数：6N+1
   - 也是单缺陷假设

5. 最坏情况测试

   - 拒绝单缺陷假设，考虑全部边界输入的组合，即各个变量输入的笛卡儿积（多缺陷）。
   - 就是多缺陷的情况会比较少、但是也要测试
   - 最坏情况测试：N 个变量的测试用例：5^N。
   - 健壮（需要增加 2 个无效输入）最坏情况测试： N 个变量的测试用例： 7^N
   - 例子：三角形问题 边界值测试：4\*3+1=13 健壮性测试：5^3=125 最坏情况测试：7^3=343

6. 随机测试

   - 即使完成边界值的全部测试，也不能发现程序的全部错误，有些错误会存在于非边界值之中。使用随机函数取出测试值，避免了人为的测试偏见。
   - 但是多少测试用例才是充分的？（后面再说明）何时停止用例生成？
   - 保证每类输出至少有一个。

7. 等价类测试

   - 划分:互不相交的一组子集,这些子集的并是全集。
   - 1）弱（单缺陷）一般等价类覆盖单缺陷
     - 测试数：取 N、 M 中的大者。（只需要覆盖单维度上的等价类就可以了）
   - 2） 强一般等价类（基于多缺陷假设）
     - 覆盖多缺陷：测试数 N×M。
   - 3）弱健壮等价类测试
     - 弱：单缺陷
     - 健壮：考虑无效值
     - 测试数：取 N、M 的大者（3）再加无效值（2）。（无效值这样是因为需要最小测试用例、去覆盖所有无效区间，就是这两个点就可以了）
     - 测试数：取 N、M 的大者（3）再加无效值（2X 变量个数）。（多一点也可以、因为需要保证到定位到错误）
   - 4）强健壮等价类测试
     - 强：多缺陷组合（笛卡儿积）
     - 健壮：考虑无效值
     - 测试数：（N+2）×（M+2）。（相当于覆盖了每个小区域）

8. 基于决策表的测试

   - c 是条件
   - a 是行动
   - 就相当于在哪些规则条件下、程序应该会执行哪些行动
   - 可以以条件组合的方式、去描述程序的逻辑
   - 实际上是功能的输入和输出映射的关系
   - 方法的问题：有时候条件组合过多、不是很好构建决策表
     - 从第一次的 256 个测试规则到现在的 13 个测试规则，测试等价类的完备性是一样的。
     - 换言之，从决策表测试方法，我们可以充分地认识到，测试用例越多，并不能增加测试的完备性。而通过分析与合并，使用尽可能少的测试用例来达到测试完备性要求，正是测试技术研究的核心内容和目标。
   - 复杂关系用决策表来测试
