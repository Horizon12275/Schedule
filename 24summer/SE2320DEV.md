## 6.28

分表

分库

通过中间件来实现

对上层应用是透明的

要写详细的端到端测试

主键索引 非主键索引 覆盖索引

load testing stress testing soak testing

监控每一个环节用的时间

要有量化的肺功能性指标

没有域名的要快一点

要先去问 dns

20，30ms

步骤 1 数据和服务器在两个服务器上

实质是给了更多计算资源

磁盘是否是高性能（数据库磁盘）

影响 io 速度

最直接的提升

需要 tomcat 本地缓存和额外的分布式缓存

缓解数据库的压力

写多读少 加缓存没有意义

横向扩展 单体可以做负载均衡 用 nginx

（因为 tomcat 的单体承载并发数有上限）

读写分离

读数据库和写数据库

只需要数据库之间的同步

进一步：分库或分表 根据不同业务的数据 分在不同的数据库里

进一步：单个 nginx 成为负载瓶颈

解决：给 nginx 做负载均衡

并发 100w 已经很大了

进一步：从单一数据中心到跨数据中心的负载均衡

（不同的 dns 解析到不同的 ip，自动分配离得最近的 ip）

到最近的数据中心

进一步：分布式文件系统 搜索引擎（数据库层）

然后 拆分应用

然后 微服务

然后 云原生（解决资源利用率的问题）

不能杀鸡用牛刀

不需要那么大的架构需求

数据库里的业务 离线业务

重新部署？

部署的顺序也会影响性能

## 7.1

修改要方便明晰

全部走 ai 处理

用户只需修改 无需创建

服务日志与监控

可以自我管理 自愈的云环境

交付的不是可执行程序 是一个可用的服务

拆成微服务的方式需要研究和统一

肯定要多个实例

讲了讲 gateway 和负载均衡

怎么升级 是不是要挂掉

可以一个一个升级

讲了讲微服务

通过消息中间件彻底解耦

服务只和消息中间件通信

服务间

用了中间件 全是异步

ai 生成 roadmap

熔断

级联调用服务的时候 会有问题

会占用内存 不会被释放

连锁反应挂掉

有耦合就要熔断 雪崩效应

所以要用消息队列

周三讲前后端测试

容器也有其他的

pr 后要集成测试 端到端测试 新代码加进来后 没有引入新的问题

每个人写完之后要通过单元测试

持续编译不等于持续集成

持续集成的条件 是做各种测试

单元测试用例

端到端测试用例

不然没有意义

最大的核心是有没有很多测试

没有用例就是白做的

不能太少 1，2 个不够

没有意义

保证代码质量

最基础的是容器

数据库用容器部署？

有 checkpoint 的容器

快照启动

解决有状态问题

容器一开始不流行 是因为 linux 对容器的支持不全

kubernetes

工具 自动生成 dockfile

数据库设计 没有公理定理 只有最佳实践

但有约束条件

要知道 我想要什么

性能还是其他指标？

一致性？

范式 只是关系型的指导原则

只是留给我用来做妥协的

架构师好不好 就是有没有敏锐的眼光发现业务特点

不只是按照范式设计完就好了

还要做 tradeoff

存的内容

静态数据和动态数据

动态数据是业务生成的数据

分为两种

一种是日志处理数据

需要存储 日志文件或者持续数据库

还有就是非日志 就是业务相关

读多写少 写多读少这种

静态数据没听清

范式主要解决数据一致性的问题

不然就要通过代码保证数据一致性的问题

所以读多写少 可以降低范式要求

增加性能

多存一点无所谓 不是内存

为什么 index 要用 b+树的好处

叶子结点是数据

非叶子节点是索引

mysql 把 b+树序列化存储到磁盘上

索引的问题是回表的问题

搜一下

怎么建索引

推断一下一个 mysql 的 table 最多能有多少记录

（有上限

同一个 entity 可能会保存在多个表里

这样的原因是因为数据库出现得太早了 没设计到上限

每张表 1w 条记录？

做校验的检索次数

不太需要关注复杂 sql 怎么写了

自动写 sql ai

mysql 中用 b+树的缺点？

不同 sql 语句的执行性能会不一样

比较少关注

做数据一致性检查开销高

写多读少 不用关系型数据库

没有意义

感觉也可以 先导入离线数据 ai 根据离线数据进行查询

本质是要写好测试用例

cicd 的节奏

scrum 的实践

## 7.5

云原生 cncf

serverless 不能太复杂

kubernetes

目前只能解决小的问题

jvm 和 java 虚拟机

有时候会慢 gpu 网络 磁盘 不能直接充分利用操作系统的资源

js 运行在浏览器上

和操作系统没有关系

k8 和消息中间件

后端只会升为业务 关键在于架构

## 7.8

分表

分库

通过中间件来实现

对上层应用是透明的

要写详细的端到端测试

主键索引 非主键索引 覆盖索引

load testing stress testing soak testing

监控每一个环节用的时间

要有量化的肺功能性指标

没有域名的要快一点

要先去问 dns

20，30ms

步骤 1 数据和服务器在两个服务器上

实质是给了更多计算资源

磁盘是否是高性能（数据库磁盘）

影响 io 速度

最直接的提升

需要 tomcat 本地缓存和额外的分布式缓存

缓解数据库的压力

写多读少 加缓存没有意义

横向扩展 单体可以做负载均衡 用 nginx

（因为 tomcat 的单体承载并发数有上限）

读写分离

读数据库和写数据库

只需要数据库之间的同步

进一步：分库或分表 根据不同业务的数据 分在不同的数据库里

进一步：单个 nginx 成为负载瓶颈

解决：给 nginx 做负载均衡

并发 100w 已经很大了

进一步：从单一数据中心到跨数据中心的负载均衡

（不同的 dns 解析到不同的 ip，自动分配离得最近的 ip）

到最近的数据中心

进一步：分布式文件系统 搜索引擎（数据库层）

然后 拆分应用

然后 微服务

然后 云原生（解决资源利用率的问题）

不能杀鸡用牛刀

不需要那么大的架构需求

数据库里的业务 离线业务

重新部署？

部署的顺序也会影响性能
