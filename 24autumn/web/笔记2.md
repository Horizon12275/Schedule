## 09 Web Services

1. 原始的前后端交互通过 restcontroller、但是 CRUD 每个方法都有一个 url pattern，这样好不好？

2. 第一个问题：是否只能 http 协议？（有很多协议、比如 smtp、ftp、sftp）还是说用 method 或者用 data 驱动？

3. 在跨语言的时候应该用什么时候调用？（同 java 语言的时候用 rmi 调用）

4. 在 www 的网络之下、仍然能访问到 alipay（在广域网上，对于 RMI 完全不可能）

5. service 不仅仅是一个 method 或者是一个 function（实现解决跨语言、操作系统、数据库的问题、通过 service 进行屏蔽）

6. REST：传递数据

7. SOAP：传递方法的调用（方法的签名、方法的参数列表）Simple Object Access Protocol（基于 xml）

8. 主要的内容在 body 里面、包含了对一个方法的描述

```java
  public interface TravelAgent {
     public String makeReservation(int cruiseID,
           int cabinID, int customerId, double price);
  }
```

9. WSDL: Web Service Description Language（描述一个 web service 的语言）, 通过 wsdl 可以生成客户端代码 （可以自动生成）

10. port 可以看作一个接口类、然后可以暴露出不同协议的方法

```xml
<message name="RequestMessage">
        <part name="cruiseId" type="xsd:int" />
        <part name="cabinId" type="xsd:int" />
        <part name="customerId" type="xsd:int" />
        <part name="price" type="xsd:double" />
</message>
<message name="ResponseMessage">
        <part name="reservationId" type="xsd:string" />
</message>
<portType name="TravelAgent">
   <operation name="makeReservation">
      <input message="titan:RequestMessage"/>
      <output message="titan:ResponseMessage"/>
   </operation>
</portType>
<!--binding element tells us which protocols and encoding styles are used -->
<binding name="TravelAgentBinding" type="titan:TravelAgent">
 <soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http"/>
 <operation name="makeReservation">
     <soap:operation soapAction="" />
     <input>
      <soap:body use="literal" namespace="http://www.titan.com/TravelAgent"/>
     </input>
     <output>
      <soap:body use="literal" namespace="http://www.titan.com/TravelAgent"/>
     </output>
 </operation>
</binding>
```

11. 这个 style="rpc" 也有很多种，比如 document、rpc、literal、encoded

12. 通过 binding 可以指定协议、比如 http、ftp、smtp

13. 这个 wsdl 文件有什么作用？比如说有一个接口的实现类，可以对着接口生成一个 wsdl 文件，这个文件是其他端，比如说 c# 可以访问的，然后 c# 拿到这个 wsdl 文件之后还会有一个实现类会把这个 wsdl 文件转换成一个类（这个类并不知道业务逻辑，相当于做的是封装和解析 request 和 response 消息的逻辑），然后这个类就可以调用这个接口的方法，然后通过 soap 把这个方法调用传递给 java 端，就可以通信了。

14. 但是要知道有哪些服务可用、所以会有一个第三方的注册表、比如 java 注册 wsdl、然后 c# 从注册表里面找到对应的服务。（屏蔽掉具体应用的位置）（ppt 上有图）

15. header 里面要指定为 xml type

16. 示例代码中、producer 暴露服务、consumer 调用服务

17. 有不同的方法、jaxb 和 jax-ws

18. SOAP-based Web Services （耦合度高）

- Coupling with the message format
- Coupling with the encoding of WS
- Parse and assemble SOAP （解析有开销）
- Need a WSDL to describe the details of WS（需要额外的文件去描述）
- Need a proxy generated from WSDL（需要代理去解析）

It is a time-cost way to implement Web Service with SOAP

- We should find a new way to implement WS

19. REST：REpresentational State Transfer（数据驱动）

Representational:

- All data are resources. Representation for client. （所有数据在互联网上唯一标识、可以用 uri 拿到数据）
- Each resource can have different representations （拿到的数据应该显示的是什么、怎么去呈现、由客户端决定）
- Each resource has its own unique identity(URI)

State:

- It refers to state of client. Server is stateless. （服务器端无状态）
- The representation of resource is a state of client.

Transfer: （在访问不同资源的时候、前面的状态会被传递）

- Client’s representation will be transferred when client access different resources by different URI.
- It means the states of client are also transferred.
- That is Representation State Transfer

应该叫/person/1，而不是/findPerson/1 (这个是一个动作)（怎么去改 CRUD 呢）

20. 这个 CRUD 的方法应该根据 http 的 method 来区分，比如说 get、post、put、delete

21. 所以是靠 url 做设计、然后用 method 去区分 CRUD ，这样才算是 restful，按照实例来。

22. 这个只是类似 标记，可以自定义。

23. 实现解耦、前端对修改无感知（这个和前面的 soap 作比较，前后端绑定）

24. 因为是 restful、所有返回的是 json

25. 所以对于不同语言交互的解决方法

    - 第一种是 xml 描述 request 和 response，和方法
    - 第二种是通过 http 的 crud 方法，然后返回 json

26. 对于广域网的解决方法

    - 上面两个方法就能解决。

27. alipay 是 int 到分的金额

28. Advantages:

    - Across platforms （跨平台）
      XML-based, independent of vendors
    - Self-described （自描述）
      WSDL: operations, parameters, types and return values
    - Modulization （模块化）
      Encapsulate components
    - Across Firewall （跨防火墙）
      HTTP

    Disadvantages:

    - Lower productivity
      Not suitable for stand-alone applications （单体不行）
    - Lower performance （解析有开销，同一个进程就不用 http 了）
      Parse and assembly
    - Security （安全性需要额外的机制）
      Depend on other mechanism, such as HTTP+SSL

29. 最后还讲了 ssl 的非对称加密。

## 10 Microservices & Serverless

1. 不应该将搜索结果的 key 和 result 存在 redis 里、因为会有维护一致性时的问题。

2. 前端来了 query 之后、不是马上执行的、会先把 query 变成一个 query plan、然后再执行。（可能 query1 和 query2 显式地不一样、但是生成的 query plan 是一样的，抽象语法树是一样的、才会使用 mysql cache）

3. 将 ip 和端口注册到注册中心里，然后在注册中心里通过服务名找到对应的 ip 和端口，而不是直接访问 ip 和端口。

4. 然后需要一个 gateway、通过 gateway 以 name 的方式访问服务，位置由 gateway 去查注册中心得到

5. 让 client 和其位置解耦。

6. gateway 还会有一个负载均衡的策略、比如说轮询、随机、权重、最少连接数。

7. 独立数据库可以提高容错性，但是一个流程可能需要访问到多个数据库。通信的开销变大。（性能受损）

   - 所以引入消息队列、前后端采用异步通信的方式去弥补。（只是能马上得到响应、但不是结果）
   - 也能屏蔽位置、因为通过消息队列中的 topic 通信。

8. 系统分离部件越多、越不可靠（越容易出错）

   - 所以需要事前监控、事后分析
   - 需要容错和服务降级

9. 定位问题：链路追踪

10. 其实还是从 eureka 里面拿到服务注册在里面的位置、拿到这个位置之后、再去用这个位置直接调用这个服务。

11. 任何服务默认注册进去是一个集群。

12. 前端发请求发到 gateway、gateway 通过 eureka 拿到服务的位置、然后调用服务。

13. gateway 提供统一的访问网关入口，eureka 提供和位置解耦（如果重启了，位置会变，eureka 会自动把服务注册进去，但是访问的代码不需要改动）

14. 没有 gateway 也可以、但是有了之后、只需要改写配置的 yml 文件就可以了，而不需要修改代码。

15. 函数式服务的无状态指的是什么？函数式服务为什么容易扩展？

    - 状态：一种是在内存里、比如 session、还有一种是在数据库里、比如订单状态
    - 对于有状态的、比较难维护
    - 无状态的：它的输出只与输入有关、不依赖于其他的内存里或者是数据库里的状态、所以可以很容易地扩展
    - 而且执行完一个函数之后、不会对后续的函数进行影响
    - 所以不需要知道之前执行了什么、服务器端就不需要维护状态（不需要配数据源之类的）

16. 一种方案是状态推到客户端去维护、一种是集中在服务端维护

17. 无状态的服务是事件驱动的。不需要关联服务器基础设施的状态。

18. spring cloud function 是一个函数式编程的框架、可以用来开发无状态的服务。

19. 需要包在 function 和 flux 里面、然后通过 spring cloud stream 来调用。（直接通过函数名访问）

20. 也可以通过 compose 进行函数的组合

21. 这个配置的时候、每个都需要配置一下 cloud starter eureka 包。

22. 这个参数如果是一个原生类的话、貌似在 requestbody 里面不需要用 json 格式、比如说就一个字符串、直接传就可以了。但是需要加上@requestbody

23. 这个 gateway 需要配置 cors、在配置文件里设置

24. 由于每次都会处理一次跨域、所以每一轮处理的时候会在响应头里面再加一层 cors 的头，正常情况下基于以上配置即可，但是由于目前的项目的下游微服务也配置了可以跨域的相关配置，这就导致返回的 ResponseHeader 中有多重属性，这个多重属性浏览器是不认的。所以基于此的处理方法，把下游的所有 cors 配置都取消就可以了。

25. Function 和 Flux 是来自于 Java 和 Spring 生态系统中的重要概念，特别是在响应式编程中。下面是对它们的详细解释：

    1. Function
       Function<T, R> 是 Java 8 中的一个函数式接口，它表示一个接受一个输入参数并生成一个结果的函数。在你的代码中，Function<Flux<String>, Flux<String>> 和 Function<Flux<Integer>, Flux<Integer>> 代表接受一个 Flux 类型的输入，并返回另一个 Flux 类型的输出。

    Flux<String>：表示一个异步流，可以发出 0 到 N 个字符串值。
    Flux<Integer>：表示一个异步流，可以发出 0 到 N 个整数值。 2. Flux
    Flux 是来自 Project Reactor 的一个类，表示一个响应式流，可以包含多个元素。它是响应式编程的核心概念之一，支持流式数据处理。Flux 可以处理从 0 到 N 个元素的异步序列，通常用于处理流式数据或事件。

    在你的代码中，flux.map(value -> value.toUpperCase()) 和 e.map(value -> value \* 2) 等操作是对流中每个元素进行变换的过程。

26. Flux 和 Mono 都是 Reactor 框架中的响应式类型，但它们的用途有所不同。

    主要区别：
    数据数量：

    Mono：表示零或一个元素的异步序列，适用于单一结果（如单个用户查询）。
    Flux：表示零或多个元素的异步序列，适用于多个结果（如查询多个用户）。
    使用场景：

    使用 Mono 时，你期待的是一个单一的响应，比如从数据库获取一个用户信息。
    使用 Flux 时，你可能在处理列表、流或者多项事件，比如从数据库获取所有用户或实时消息流。

27. 它这个 maven 默认是不带 web 的、所以需要加上 web 的依赖

28. 貌似这里会有一个问题、使用 redis 的时候、这个下订单的操作没法正常进行。这个错误通常表示在使用 JPA（Java Persistence API）时，您尝试删除或修改一个实体集合，但该集合的拥有者实例已经被分离（detached）或者没有正确管理。具体来说，当您使用 cascade="all-delete-orphan" 时，JPA 期望对拥有者实体（如 Book）的集合（如 cartItems）进行正确的引用和管理。

29. 这个函数计算应该在前端调用还是在后端服务里调用呢？貌似应该在前端调用啊

30. 这个函数容器在 cloud 被调用的时候、会看有没有这个容器、如果没有会马上创建一个容器、调用完之后会被马上关掉，生命周期很短

31. 或者可以把容器的操作系统层的进行保留、然后根据倒计时只更换函数层部分的代码、或者只更换语言层的环境，可以节省容器重启，做初始化环境的时间。

32. 由 spring cloud 管理需要多少个函数服务实例去处理请求（因为请求可能会有很多个）

33. 说是 gateway 和 register 不是必须的、如果重启之后位置不会变的话。

34. 因为需要通过高层的 http 协议、所以微服务的性能会受影响。

35. session 首先未必需要维护在后端、也可以维护在前端的 kvmap 和 cookie 里面。还有一种方法是通过额外的 session server 去维护

## 11 MySQL Optimization

0. 写进去的 sql 语句会通过 query plan 进行类似编译的优化、然后再进行查询，会将查询的结果存到 cache 里面。

1. 下面的一些是数据库层面的优化。

   - 存储的内容会有优化关系，比如学号应该存 Integer 还是 String，如果存 Integer，这个就会节省内存。或者是 char 和 varchar 的区别
   - 存储的索引应该建立到哪个列上面、还是建立几个列的索引？
   - InnoDB 的存储引擎是什么？不是 mysql 的原生引擎
   - 行格式的问题？比如 varchar（10），那就是 0-10 都可以，如果它里面只存了 2 bytes，那么剩下的 8 bytes 怎么处理？是应该等长的还是节省空间？或者如果学号的前缀都是相同的、是不是就可以压缩一下，是不是动态的。（空间和时间的权衡）（取决于经常发的 query 是什么样）
   - 锁级别？
   - cache 的大小？而且这里的 cache 也不是一整块的、而是分开来的。

2. 还可以做一些硬件层面的优化

   - Disk seeks. （如何寻找空闲区域）
   - Disk reading and writing. （ssd 和 hdd）
   - CPU cycles.
   - Memory bandwidth.

3. 还有 sql 语言的可移植性，需要包装

4. 索引用 B，B+树，因为读的内容大小和 pagesize 差不多，而且可以范围查询（有指向兄弟节点的指针）

5. 当更改索引指向的内容的话、需要花费额外的时间去维护索引。

6. 如果 scan 全表的时间比通过索引找到、然后再改动的时间还要少的话、那就不需要做索引，扫描一下就可以。（因为会有建索引和维护索引的开销）

7. 大多数 mysql 索引都在 B-树里面，除了：

   - 像空间索引这样的、就会用 R-trees
   - 内存表也支持哈希索引
   - 全文索引用的是反向列表

8. 聚簇索引：每个表只有一个（默认上是在主键上建立）（可以在经常做搜索的内容上面设置聚簇索引）

9. 主键优化：

   - 如果主键由多个列构成、那么会让这个索引的尺寸增长得很快。
   - 如果有空的内容作为索引、会从空的那个地方、延长出一个链表，降低索引效率，所以最好不要为空。是否为空的实现是通过最后一个 bit 的 0 和 1 来实现的、每次都会检查，会消耗时间。

10. 空间索引：

    - 把空间分为了很多个区域、对区域去做索引（八叉树）

11. 外键关联：

    - 为什么需要外键：会有多张表，之间有关联
    - 为什么会有多张表？因为一张表中每一列的详情使用频率会比其他的更高，比如 book 的信息
    - 第一个好处、可以从 hdd 上面一次读一个会被经常使用的 page
    - 第二个好处、不经常使用的数据可以存储在其他地方
    - 第三个好处、可以复用数据、冗余数据会比较少，表比较小、搜索速度就比较快（IO 更少）

12. 索引：

    - 如果这个字段的长度太长了怎么办，可以把这个前面的 n 个字符作为索引（对于 blob 和 text 是强制的）
    - 会有四种格式：
      - REDUNDANT （留下多余的空间）
      - COMPACT （压缩空闲的空间）
      - DYNAMIC
      - COMPRESSED (只存不一样的)
    - 如果 search 的内容超过了索引的长度、可以先去根据 prefix 过滤、然后扫描剩下的
    - TF 和 IDF （频率和频率的倒数）
    - LIKE 的时候也可以用到
    - 哈希索引对范围查找不太行，但是判断等或者不等很快
    - 也可以做升序降序索引，虽然只有两个字段、可以根据升降做不同的索引组合（可以有 4 种）

13. 多列索引：

    - 索引建立的顺序也会有影响，决定因素应该是到时候这个索引会被使用的方式有关
    - INDEX name (last_name,first_name)
    - 如果建立了上面这种索引，可以先 select lastname 在前面的，会利用到这种索引（ppt 上有例子，除了 lastname or firstname）

14. You can get better performance for a table and minimize storage space by using the techniques listed here:

    - Table Columns （比如 Int 和 Mediumint，或者设置为非空、因为会有额外的位和检查的开销）
    - Row Format（上面提到的四种 ROW Format，Reduundant 已经不用了）（而且会有编码方式的不同、用 unicode 还是 utf8）
    - Indexes （主键应该越短越好）（一种主键是 Int 递增、8bytes，一种是 UUID，32 位 Hex。需要后面一种的原因是、因为前面保证主键递增需要额外的开销，比如再来一个线程，当用户大量的时候、就会有问题。实现是通过两个 agent，每次给 agent 分配一段的 id，比如分配 1000-1999 和 2000-2999，直到用完的时候再请求新的）（但是 UUID 是通过 IP:port:timestamp:random 的方式产生的，生成策略简单，好处是唯一的、但是坏处是太长、而且不知道插入的顺序）（维护索引节点的分裂和调整会有开销、要减少这个操作数）（分列做索引、效率不一定高、不如单列）（如果用了多列索引、那么最好把能筛选掉多的内容把它放到前面）（为什么要用 prefix 做索引、因为短的索引更快，因为读的 page 里面包含的索引更多）
    - Joins （如果需要对两个表做 join、而且两个表里的内容和含义和数据都是一样的、那么列名和数据类型应该相同、不然 join 之后就会慢）
    - Normalization（范式化、在 3 范式和 BCNF 范式里面选择，4 范式会做频繁的 join，范式低会提高维护数据一致性的开销、而且造成数据冗余）
    - 使用数值型的类型去存
    - 使用字符时、需要用相同的字符集（unicode、utf8）（尺寸小于 8kb，用 varchar，大于 8kb，用 blob，varchar 是存在一个 page 的相邻的内存块里、如果大于一个 page 的一半的话、就会报错，但是 blob 是存一个指针、然后在另外的地方存数据 ）（临时的内存表里面不能存 BLOB）（如果有很多记录不需要读、放到另外的表里面、保证单条记录小）

15. 对于打开的表的优化：
    - 打开的很多表里面会有默认的系统的表
    - 会有多版本的数据控制，通过 MVCC（多版本并发控制）来实现
    - table_open_cache 是打开的表的数量，根据 Max_connections 来设置
    - 怎么做表的打开和关闭？用的不是 LRU，是把内容放到中间？
    - 可以展示当前打开的表的数量（会有多版本的控制、实际没有那么多）
    - 为什么会建立临时表？比如 union 的时候、会建立临时表，因为 sql 就是进行关系运算，需要额外的存储内存
    - mysql 对数据库个数和表的个数都没有上限。（但是操作系统会对目录数有限制，进而限制数据库个数）（表的大小由操作系统规定的最大文件大小限制）
    - Row Size Limits 65535 （ppt 第 51 页上的是什么意思？）（ppt p52 开始有例子，因为 text 和 blob 存的只是指针、只存 9-12 字节）（为什么 varchar 65535 直接设置是会报错的，因为还会有额外的几个 byte 去存它的长度信息、但是 65533 就是可以的了）（同样地、如果是可以为空的，那么也需要额外的 bit 去存储）（最后一个报错是因为 char，判断超过了页的一半，就失败了，这个貌似是规定、否则效率会低、同样的对于最后一个 row size 的例子也是一样、一行所有的不能超过半页？varchar 可以、char 不行、因为 varchar 是可以压缩的）（而且是定义的时候是可以的、但是如果真的插入 varchar 里面那么多内容、貌似也会报错）（char 是对齐的、varchar 是压缩的）

## 12 MySQL Optimization

1. InnoDB table 表优化:

   - OPTIMIZE TABLE : 可以让表的碎片整理（把很多小块整理成一大块），然后重建索引，提高性能。（当数据量大小稳定，而且尺寸达到一定程度很大的时候）（本质是复制碎片然后调整索引，所以会浪费时间，不能频繁做）
   - 如果主键比较长的话、那么占的磁盘空间会比较多（因为默认会在主键上面做索引）
   - 尽量用 varchar，不要用 char（因为 varchar 可以压缩）（特别是对于很多空的字段，如果空的话、就可以压缩）（除了定长和都有的字段、用 char）
   - COMPRESSED 行格式可以对有很多重复内容的数据进行压缩（比如前缀相同的、可以压缩，数值和字符串都行，字符串有重复、或者数值很接近）（但是缺点是解析会慢，所以只有当这个表的空间很大的时候才用，小的时候不用）

2. 事务管理的优化：

   - 默认每个 sql 语句都是在一个事务里面的，可以通过 autocommit 来设置多久提交一次。也可以设置 autocommmit 为 0，然后手动提交。
   - 如果一个事务里面只有类似于 select 的操作、那么 innodb 会对这个只读事务进行优化。
   - 要避免很长的事务，因为会涉及到很多的 inserting、updating 很多行，而且会有加很多锁的问题。（这个问题还不能通过重启解决、因为重启的时候会有 rollback 的操作，又加锁了）
   - 可以通过调整  buffer pool  的大小来优化性能，因为 buffer pool 是 innodb 的内存缓存，可以存储数据和索引，减少磁盘 I/O 操作。（一般是脏页到了 buffer 的 10%的时候会写、因为如果超过 10%，恢复的时候开销会很大）
   - 可以通过设置  innodb_change_buffering 来设置 innodb 的写入策略，可以设置为 all、inserts、none。（all 是所有的都缓存，inserts 是只缓存插入的，none 是不缓存）（而且实际业务种一般不删除，是通过标记删除的方式）
   - 避免大规模的数据操作事务，会导致数据不一致的问题
   - 也要避免长时间运行的事务、因为会有锁的问题、而且如果 non-steal、会占用很多内存（产生冲突之后不好恢复）

3. 大量数据导入的时候的优化：

   - importing data into InnoDB, turn off autocommit mode，最后统一 commit
   - 同样地、也可以关掉 UNIQUE constraints 的检查，然后最后再检查一遍
   - 外键关联也是一样、可以关掉 foreign key checks，然后最后再检查一遍
   - with auto-increment columns, set innodb_autoinc_lock_mode to 2 (interleaved 穿插) instead of 1 (consecutive 连续).（自增的数据维护在一个系统表里）（因为大量数据导入的时候、肯定不是一个线程，设置为 interveaved 的时候、当有多个线程的时候、读走的是一个区域的数值，然后分别去插入）
   - 当多行插入的时候、用 multiple-row INSERT syntax 、避免额外的通信开销

4. Queries 的优化：

   - 聚簇索引：指的是 B 树上的叶子顺序和在磁盘上的顺序是一样的，所以可以减少磁盘的读取
   - 不要让主键太长，因为会占用很多的空间在索引里面
   - 所以主键应该是经常搜索的内容，而且会涉及到批量读取的内容
   - 要根据查询的需求做复合索引（根据支持的功能），不要在每一列上做单列索引
   - 索引列本身不要包含空的值（从 null 开始一堆的链表）

5. 磁盘 IO 的优化：

   - P10 有 3 个例子
   - fsync threshold 是什么？
   - 会有不同的存储数据、如果需要随机访问、那么放在 ssd 上面、如果是顺序访问、比如 logfile、那么放在 hdd 上面（根据磁盘的特性）
   - P11 Increase I/O capacity to avoid backlogs 这个是什么，checkpoint 需要提高磁盘 io 空间？

6. DDL 操作，比如创建表、修改表结构、删除表等操作：

   - Use TRUNCATE TABLE to empty a table, not DELETE FROM tbl_name.
   - 不要修改主键、因为会涉及到很多的索引的重建

7. 内存表的优化：

   - 应该放常用的而且不重要的数据（而且只读、尽量少写）
   - 一般使用 hash index、也可以指定用 b 树，b 树对范围查找比较好，哈希对等值查找比较好

8. buffer pool 的优化：

   - 会有 chunk size 和 pool size 的区别
   - chunk size 默认是 128MB，代表 buffer pool 里面的一个块
   - 这个 buffer pool size 必须要是 chunk size 的整数倍，因为 chunk 是最小的单位
   - 可以设置多个实例、为了多个线程并行读取一个 table、减少竞争 For systems with buffer pools in the multi-gigabyte range, dividing the buffer pool into separate instances can improve concurrency, by reducing contention as different threads read and write to cached pages. （对于大的 buffer pool，可以分成多个实例，通过减少每个线程读写缓存页的竞争来提高并发性）
   - Newly read blocks are inserted into the middle of the LRU list.（新读取的块会插入到 LRU 列表的中间，一般是 3/8 的位置， 3/8 from the tail of the LRU list）
   - LRU list into two segments 也会有类似 generation 的旧代和新代的概念
   - Prefetching (Read-Ahead)来减少磁盘 io 的次数、提高性能
   - 也可以设置同时最多有几个线程去把 dirty page 写到磁盘上 innodb_page_cleaners
   - the low water mark value 10% 也可以调整
   - 缓存的内容也可以做恢复、下次再启动的时候、可以减少 warm-up 的时间（通过记录 buffer pool 里面最常用的页）

## 13 MySQL Backup & Recovery

1. 备份：

   - 一个是为了数据库崩溃时的恢复
   - 还有一个是防止 mysql 升级后的数据丢失

2. 备份的种类：

   - 逻辑备份：通过 sql 语句去备份（版本迁移，比较慢、适合数据量比较小的情况，可以移植到不同的机器的数据库上）
   - 物理备份：直接备份文件（适合比较大、比较重要的数据库，恢复也会比较快，不能适用版本迁移）

   - 在线备份：不停机的备份（会有不一致的问题，用户体验较好，但是要加锁）（hot）
   - 离线备份：停机的备份（会有停机的问题）（cold）
   - warm backup：只允许读，不允许写（warm）

   - 远程备份和本地备份：只是远程操控和本地操控备份操作的情况、备份的位置还是在数据库的机器上

   - 快照备份（增量式备份）：用逻辑备份备份变化的部分。（mysql 不支持快照备份）

   - incremental backup：只备份变化的部分（mysql 使用 binlog 实现）

   - Backup Scheduling, Compression, and Encryption

3. mysql 备份方法：

   - 企业版的 mysql 有自己的备份工具
   - Innodb 用的是 hot backup，其他引擎的表用的是 warm backup
   - For InnoDB tables, it is possible to perform an online backup that takes no locks on tables using the --single-transaction option to mysqldump.
   - 也可以保存成不同格式的文件
   - 也可以关掉 binlog、但是就没法实现增量式备份了（binlog 也是 append）
   - 也可以做主从备份（然后做负载均衡、比如读操作可以到所有节点、然后写操作只到主节点）

4. 数据库恢复方法：

   - For cases of operating system crashes or power failures, we can assume that MySQL's disk data is available after a restart.（因为有 log，可以直接恢复）
   - For the cases of file system crashes or hardware problems, we can assume that the MySQL disk data is not available after a restart.（所以会需要备份）
   - This backup operation acquires a global read lock on all tables at the beginning of the dump.（备份策略：备份的时候会加锁，这里 ppt 上有一个例子）
   - 对于没有被截断的 binlog 文件，要用 mysqlbinlog gbichot2-bin.000009 ... | mysql 里的 ...，说明还没有被截断
   - log 文件和数据文件可以分别存在不同的硬盘上、这样就避免了一个硬盘坏了之后、数据和日志都丢失的问题
   - tab-delimited text 用 tab 分隔的文本文件

5. 可以用 merkle 树来存储哈希码，然后通过对比这棵树来判断保存和恢复的数据是否一致（dump 和 recovery 的时候同时建树）

6. 下面的这种方法进行多线程地恢复是不对的，因为可能第一个 binlog 会创建一个临时表、然后第二个 binlog 会用到这个临时表，但是这个临时表在 binlog001 运行完之后、会被删除，就会在第二个 binlog 里报“unknown table”

```
shell> mysqlbinlog binlog.000001 | mysql -u root -p # DANGER!!
shell> mysqlbinlog binlog.000002 | mysql -u root -p # DANGER!!
```

7. 也可以指定时间点去做 binlog 的恢复（可以跳过 file 中的一些操作）

8. 做完 full backup 时候、会把先前的所有的 binlog 都删除，然后重新开始

9. binlog 为了系统崩溃的时候恢复。
