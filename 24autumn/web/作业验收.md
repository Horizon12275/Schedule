## 作业验收

1. 可以在演示的时候启动 eureka-server 和其他的四个服务、默认情况下是打开 redis 进行缓存的，后面演示 redis 的时候貌似可以把容器删了再演示

## hw1

1. 正常演示进行记录登录时间的流程

2. 所使用的 Scope 属性值的原因：

   - TimerService 使用了@Scope(value = “session”)，因为要求记录的是用户每次登录 E-BookStore 后的会话保持的时间，而在不同浏览器登录时、会话是不同的。这个要求是需要维护多个用户间独立的状态。因此需要设置为“session”，使得 TimerService 对于每个会话能够创建对应的实例，持续维护登录时间的变量。

   - LoginController 中、虽然不维护登录时间的变量，但是需要注入对应的 TimerService 实例，如果设置 LoginController 为 singleton，会报出实例依赖注入错误的异常。因此在这里也设置为@Scope(value = “session”)，保证成功注入。

   - （注：这里询问过助教、也可以通过设置 LoginController 为 singleton，同时在 TimerService 设置代理模式 proxyMode 保证每次调用 LoginController 的时候、注入对应 session 的 TimerService 实例，可以节约资源）

3. 演示下订单的操作、以及命令行的输出

## hw2

1. 演示下订单的操作

2. 所使用的 Transactional 传播属性值的原因：
   最终在 Service 的购买函数 purchaseFromCart，OrderDao 的 save order 函数和 OrderItemDao 的 save orderItem 函数中都使用了 REQUIRED 作为传播属性值（即不加额外设置时的默认传播属性值）。

   其中 REQUIRED 属性值表示：如果目前进程中有事务，那么就加入到这个事务中，如果没有事务，那么就新建一个事务。而 REQUIRES_NEW 属性值表示：不管有没有事务，都新建一个事务。（即使外层有事务，也会新建一个事务）即新事务 TX2 的成功或者回滚都不会影响到外层事务 TX1 的成功或者回滚。

   作业中的要求是：必须保证 orders 和 order_items 两个表的数据要么都插入成功，要么都不插入，即这两个表的插入操作必须在一个事务中完成。使用 REQUIRED 属性值满足这一要求。而如果使用 REQUIRES_NEW 属性的话、不管在 save order 或者 save orderItem 上使用，都不满足这一要求。此外，如果在 save orderItem 上使用的话，还可能会导致作业 ppt 中所述的 SQL 异常。

   情况 5，9 的事务回滚是由于插入 orderItem 时的异常导致。这个异常是因为 save orderItem 使用了 REQUIRES_NEW 属性，导致其在执行时、从包含 purchase 和 save order 的原事务 TX1 里脱离，新建了一个独立的事务 TX2，导致 TX1 被暂时挂起。然而，此时 TX1 没有 commit 提交，因此 TX1 中的 order 数据并未落盘，所以在 TX2 中尝试保存以 orderId 作为外键的 orderItem 记录时，TX2 的 orderitemDao 无法看见没有提交和落盘的 orderID，无法直接 save，无法插入 orderItem。因此最终抛出 Unable to find com.example.demo.models.Order with id 6 的异常，并使得 TX2 直接回滚。而又因为在 TX1 中，TX2 发生的异常被 try&catch 捕获处理、因此 TX1 仍继续运行。所以在这两种情况下、TX1 正常运行至结束、并提交 save order 的记录。（情况 9 中尚未运行到 result = 10 / 0 一行）因此导致 order 表中有数据、但 orderItem 表中无数据。

3. 前端呈现：即为 alert 的提示结果，可以演示一下对应的 socket 连接订阅方式

4. 对比分析：

   1. 在前端工程中，使用 JavaScript 监听订单处理结果消息发送到的 Topic，然后刷新页面。

      • 优点：实时性：能够立即响应消息，无需等待用户手动操作。
      • 缺点 1：安全性问题：在前端直接连接 Kafka，可能暴露服务端的细节，增加安全风险。

   2. 在前端发送 Ajax 请求获取订单的最新状态，后端接收到请求后将订单状态返回给前端去显示。

      • 优点 1：易于实现：基于 RESTful API 的设计，易于理解和开发，且与传统的 Web 开发模式一致。
      • 优点 2：兼容性好：Ajax 在各大主流浏览器中都有良好的支持，适合广泛的用户群体。
      • 缺点 1：延迟问题：需要定期轮询获取状态，可能导致延迟，以及造成额外的开销。如果未设置合理的轮询间隔，可能会导致用户看到过时的信息。
      • 缺点 2：并发性差：当大量用户下订单的时候、订单可能无法很快地处理完，如果用户要尽快知道订单的处理结果，会造成很多次请求还不能获取到最新的订单状态，这时的性能远不如直接通过 websocket 把处理结果推回给前端。

   3. 采用 WebSocket 方式，后端的消息监听器类监听到消息处理结果 Topic 中的消息后，通过 WebSocket 发送给前端。

      • 优点 1：高实时性，实现了双向通信，解决了使用 kafka 时告知前端订单什么时候被处理完的问题，能够立即将订单处理成功的消息推送给前端，用户体验极佳。
      • 优点 2：减少流量：只在有订单处理成功的新消息时才进行数据传输，降低了不必要的网络请求。
      • 缺点 1：兼容性问题：虽然大多数现代浏览器支持 WebSocket，但部分老旧浏览器支持 WebSocket。
      • 缺点 2：连接管理：引入了 ws 协议，需要额外处理连接的生命周期、重连逻辑等问题，增加了项目复杂度。

## hw3

1. 演示过的正常接受订单处理结果的操作

2. 为什么要选择线程安全的集合类型来维护客户端 Session：
   因为在 web 应用服务中，不知道同时会有多少客户端对服务端进行连接，如果在不同线程中对一个非线程安全的类型进行读写操作，会出现并发错误。
   使用线程安全的 ConcurrentHashMap 保证所有函数对这个类型的操作都是原子性的，因此在多个客户端同时 OnOpen，OnClose 的时候、保证了对 ConcurrentHashMap 操作的原子性，避免并发错误。

   选择的类型为什么是线程安全的：
   ConcurrentHashMap 在内部使用了分段锁的机制。整个哈希表被划分为多个段（segments），每个段都有自己的锁。当线程要访问某个段时，只需要锁住该段，而不是锁住整个哈希表。这种设计保证了线程安全，也提高了并发性能，因为多个线程可以同时访问不同的段。

3. 在数据库事务管理中，持久性是指事务提交后即使数据库产生故障，事务提交的结果仍然可以在数据库中访问到，不会丢失。请编写文档回答下面的问题：

   1. 如果数据库系统在事务执行过程中不断地将事务操作的结果执行落盘操作，会带来什么潜在问题？可以如何处理？

      - 潜在问题：如果该事务尚未执行完时、发生了系统故障，由于该事务先前的操作结果已经落盘、但是该事务后续的操作尚未进行，因此会影响事务原子性
      - 如何处理：系统重启时需要根据 undo 日志中的内容回滚该事务

   2. 如果数据库系统在事务执行提交后再将事务操作的结果执行落盘操作，会带来什么潜在问题？可以如何处理？

      - 潜在问题：如果在事务执行提交之后、在结果落盘之前、发生了系统故障，相当于已完成的事务尚未将操作写入磁盘，即影响了数据库的持久性，因为此时事务提交后由于数据库产生故障，事务提交的结果不能在数据库中访问到，数据丢失。
      - 如何处理：系统重启时需要根据 redo 日志中的内容重做该事务

   - 原子性：撤销未结束（不带 Commit、Abort 标记）的事务
   - 持久性：重做已经结束（带 Commit 或 Abort 标记）的事务

   - 原子性
   - ① 事务运行期间不刷盘，故障系统重启后自动保证原子性；
   - ② 事务运行期间刷盘，故障系统重启需回滚该事务

   - 持久性
   - ① 事务完成（commit、abort）时刷盘，故障系统重启后自动保证持久性；
   - ② 事务完成时不刷盘，故障系统重启后需重做该事务

## hw4

1. 展示连接 redis 的代码和缓存的代码，可以删掉 redis 容器再演示首次读的情况，可以用写路由的方式切换书本页面，避免显示分页查找的结果显示无法保存

   - opsForList()是一个操作，可以用来操作 list，比如 rightpush 和 leftpop。opsForValue()是一个操作，可以用来操作 value（普通的 key-value），比如 set 和 get。

2. 展示写数据的代码，增删改查应该都没问题

3. 解释日志

   - 首次读写：

     - 首次打开 redis 容器时，登录用户 1 后自动直接跳转至图书 1 详情页面，显示 "从数据库中获取了图书 1"，因为 redis 中尚未有该条图书的记录，需要从数据库中先拿到后、存储到 redis

   - 后续读写

     - 在图书 1 详情页面刷新，即后续读写，显示 "从 Redis 中获取了图书 1"，因为数据已经从数据库中拿到并存储到了 redis 中、因此后续读写的时候、直接从 redis 读到数据、而非再需要到数据库去获取一次数据

   - 关掉 Redis

     - 在处理 redis 未连接的异常前、关掉 redis 后、在书籍详情页面刷新、报错“Redis command timed out”、报出 Reconnecting 中，不能正常运行。
     - 在引入处理 redis 未连接异常函数后、关掉 redis、在书籍详情页面刷新、系统可以正常运行。（无法操作 redis 报出了自定义 catch 中的 log 的 error 日志、但从数据库中获取了图书，前端仍能正常显示）

## hw5

1. 实现了搜索书名的微服务

2. Gateway 和 Service Registry 在微服务架构中都起到了什么作用

   - Gateway

   - API Gateway 是一个管理微服务请求的入口点，它充当前端与后端微服务之间的中介，同时在多实例情况下还能有负载均衡的效果。在我编写的这个微服务的使用中、前端的所有请求都会先发送到 Gateway 的 url。然后，Gateway 从 eureka 注册中心找到各个实际注册的服务的位置后再进行访问。这样做可以让前端不需要知道具体的服务地址，只需要知道 Gateway 的 url 就可以了。（一种例子是当每个微服务或者容器自动重启时、其 ip:port 可能会发送变化，但是这种通过 Gateway 的访问方式可以屏蔽这种变化。client 通过 Gateway 调用 service 的方式，使得使用服务和 service 的实际位置解耦）（此外还易于使用配置文件进行访问方法的配置）

   - Service Registry

   - 在作业中使用了 eureka 作为 Service Registry，当一个服务启动时、它会注册到这个注册中心里，让注册中心统一保存管理这个服务的实际位置。和上面提到的例子类似、当该服务进行重启时、其位置可能会发生变化。但只要将服务注册进去 eureka，就不需要改变通过 Gateway 访问服务的代码。提高了可维护性。

3. 展示前端使用函数式服务进行价格计算的代码

4. 解释函数式服务的无状态指的是什么？

   - 对于“状态”的定义：一种是在内存里保存的状态、比如 session、还有一种是在数据库里、比如订单的数据信息等
   - 而函数式服务的“无状态”的意思是：函数式服务的输出只与输入有关、不依赖于其他的内存里或者是数据库里的状态。而且执行完一个函数之后、不会对后续的函数服务产生结果上的影响

   函数式服务为什么容易扩展？

   - 因为函数式服务是无状态的、所以这个服务器就不需要进行状态的维护（不需要配数据源之类的）意味着每次调用都是独立的，且不会受到之前调用的影响。使得横向扩展变得简单，因为可以随时增加或减少实例以应对变化的负载。同时、函数可以轻松组合成更复杂的函数服务或工作流，这种模块化设计使得整体系统更容易扩展和维护。与微服务架构相结合，每个函数可以实现一个特定的业务逻辑，使得各个功能模块可以独立扩展，便于在需要时快速调整。
