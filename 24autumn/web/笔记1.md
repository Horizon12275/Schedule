## 01 Stateful and Stateless

1. 本地缓存比较小、所以需要再有分布式缓存

2. 大部分数据是只读数据、所以可以使用缓存，而不是每次都去数据库查询

3. 主从复制的服务器可以每隔一段时间切换一下角色，保证多机器的冷热均衡

4. CDN 服务器：内容分发网络，可以缓存静态资源，减少服务器压力，在不同地区有不同的服务器节点，可以加速访问

5. 反向代理服务器：用于分发请求。“反向”这个词强调的是代理的作用是代表后端服务器来接收客户端的请求。反向代理则是指客户端直接向代理服务器发送请求，而代理服务器再将请求转发到后端的目标服务器。（让音视频可以在线点播）

6. 数据访问网关：封装数据访问的细节，提供统一的数据访问接口，对外提供服务（比如数据到底是从数据库还是缓存中获取）

7. 消息服务器：把服务变成基础设施

8. 微服务：抽离出来公用的服务，比如 A 应用和 B 应用都需要用到支付服务，那么就可以把支付服务抽离出来；或者比如说登录服务、注册服务等等

9. http 是无状态的协议，如果有状态，内存会爆

10. 实例池：限制每种实例的数量，防止内存爆炸，然后用 LRU 策略来淘汰，但是会有 swap out，硬盘读写，会影响性能

11. springboot 中也可以通过配置@Scope("prototype")，@Scope("session")等来控制实例的创建。prototype 即每次请求都会创建一个新的实例（任意情况下都是新的），session 即每个会话创建一个实例（见 ppt 表格）。singleton 即单例模式，即整个应用只有一个实例，这个是默认情况下的。request 即每个请求创建一个实例。

12. 如果需要不需要维护多个用户间独立的状态的话、就用成 singleton，如果需要维护多个用户间独立的状态的话、就用成 prototype。（状态即程序变量，比如在前端显示用户已经在线了多久，这个时间就是状态，需要在后端维护，而且每个用户的状态是不一样的）

13. 最好是有状态的内容尽量少（压缩、但是有些东西必须要靠状态实现），因为有状态的内容会占用内存，而且会有并发问题。无状态的内容尽量多。极致就是函数式编程，没有状态，只有函数。好处就是后端不用维护那么多对象，消耗资源就很少。

14. 连接的本质是一个线程，线程之间需要切换。所以连接池不是越大越好，因为线程上下文切换也是有开销的。所以连接池的大小要根据服务器的性能来调整。连接池的大小设置和用户并发数没有关系。如果高并发之后性能不行，那么就是服务器性能不行，不是连接池参数设置的问题。

15. connections = (2 \* core_count) + effective_spindle_count; （线程去做 IO 的时候，cpu 是空闲的，所以可以\*2 作为等待线程的数量）[链接](https://blog.csdn.net/Receptive2WE/article/details/122421718) 【遗留问题】effective_spindle_count 是什么？

## 02 Messaging (JMS, Kafka)

1. 同步通信的问题：因为我们是面对接口编程的。有大量实例，可能调用不成功。或者网络不佳，也会失败。（没有送达保证）同步调用也没有请求缓冲（忙了也会失败）。同步还是紧耦合的，即调用函数的时候会需要根据函数名重新修改代码。同时会比较难维护。即过于强调了发送了一个 request，就要等待 response，这样就会导致请求的阻塞。所以同步通信不适合高并发的场景。（例子 打电话和发短信的例子）

2. 如果不用消息队列，就没有 request buffer，会在 controller 或者 service 或者 dao 里面阻塞，导致可能请求会丢掉。而且前端也不知道请求的状态。这几层之间都可以通过消息中间件进行交互。比如，kafka 中有很多 Topic 的缓冲。在消息队列的场景下，client 发送请求，然后 controller 直接返回一个确认收到的响应给 client。那怎么 client 如何最终确定这个请求处理完了呢：一种是再发一次 ajax 请求，一种是 websocket，一种是把结果重新发给另外一个 B 的消息队列，然后 client 从这个 B 的消息队列里面去拿结果。（类似于发邮箱）对应于 ajax ws 和 messaging （消息队列解决一段时间内请求高峰，请求波动的问题，服务器资源不够）

3. 问题在于异步的返回值应该是什么，service.m()还可能抛出一个异常。所以也要把这个异常组成一个消息发给 B 这个结果的消息队列。

4. 消息系统是 peer to peer 的通信方式。是松耦合。在这个 topic 里面的是数据。这个是 data-driven 的，即不指明调用的方法。 SOAP 和 HTML。

5. jms 是标准的 java 里的消息队列。让通信变得异步和可靠。

6. 什么时候要用消息通信？比如下订单。（可以在闲时处理）。

7. 消息的格式：1.header（必有） 2.body（可选） 3.property （可选）

8. 消息队列的 S，C 和 P 是什么意思：S 是 send ，C 是 consumer（client 设定的），P 是 producer（server 设定的）

9. 有时候 A - Kafka - B 之间，会根据设置的 Destination 或者 DeliveryMode 来决定消息的发送和接收。比如说，如果设置了 Destination 为持久化，那么即使 B 没有启动，A 发送的消息也会被保存在磁盘上，等 B 启动之后，会把这个消息发送给 B。如果设置了 DeliveryMode 为持久化，那么即使 Kafka 挂了，消息也不会丢失。如果设置了 DeliveryMode 为非持久化，那么 Kafka 挂了，消息也会丢失，不会发到 B。（比如股市的例子，要保证时序的顺序）

10. 消息头的例子 Clients can not extend the fields

    - JMSDestination (S)
    - JMSDeliveryMode (S)
    - JMSMessageID (S)
    - JMSTimestamp (S)
    - JMSCorrelationID (C)
    - JMSReplyTo (C)
    - JMSRedelivered (P)
    - JMSType (C)
    - JMSExpiration (S)
    - JMSPriority (S)

11. 消息的属性（Property） Clients can extend the fields。比如，扩展属性，给消息加上 selector：name=“B”，就能起到筛选的作用。只能加简单类型。Property name: follows the rule of naming selectors；Property value: boolean, byte, short, int, long, float, double, String

12. 消息体：见 ppt 表格

13. java 对象能够被序列化的意思：实现一个 java 类的接口，使得能变成适合在网络上传播的数据。

14. jms：destination 分为 topic 和 queue（那个图是什么意思）都需要通过链接工厂建立一个到 jms server 的链接，然后找到数据源 datasource。（JNDI namespace）

15. 点对点的消息：client 1 的消息只会被 client 2 接收到，而不会被 client 3 接收到（queue）。而发布订阅的消息：client 1 的消息会被 client 2 和 client 3 接收到。即点对点是一对一的，发布订阅是一对多的（广播 topic）。

16. Durable 和 Non-Durable 的区别：Durable 是持久化的，即消息不会丢失。（consumer 不在线的时候，消息不会丢失）Non-Durable 是非持久化的，即消息会丢失。（不在线的时候，消息会丢失）

17. browser 只浏览

18. 重要的是类的 toString 方法的重写

19. kafka 基于日志通信，只追加（append-only），顺序写，速度快。

20. 对每个用户维护一个 offset，即每个用户都有一个 offset，这个 offset 会记录这个用户读到了哪里。这个 offset 会被保存在 zookeeper 中。如果 kafka 挂了，那么 zookeeper 会把这个 offset 保存下来，等 kafka 恢复之后，会把这个 offset 读取出来，然后继续读取。（用 zookeeper 来管理）

21. 一个 topic 里面可以放相同类型的对象（长度易于管理），也可以放不同类型的对象（缺点是要记录多个偏移量，好处是只用一个队列）。

22. topic 可以分区，比如按照用户 id 来分区，这样可以保证一个用户的消息是有序的。但是这样会导致一个用户的消息只能被一个消费者消费，所以要根据业务需求来决定是否要分区。

23. 分区的目的：可以并发，同时可以集群部署。也可以加上分区备份，保证数据不丢失（在不同机器上，保证可靠性）。

24. 会发送心跳包，如果一个 consumer 挂了，那么会把这个分区的消息发送给另外一个 consumer。

25. 最好在事务里发送消息

26. broker 是一个 kafka server，一个集群里面有多个 broker，每个 broker 里面有多个 topic，每个 topic 里面有多个 partition，每个 partition 里面有多个 offset。

27. 在 Kafka 中，`groupId` 用于将多个消费者组织成一个消费组。将两个 `@KafkaListener` 的 `groupId` 设置为相同的含义如下：

    - **同一组中的多个消费者**：当多个消费者属于同一个消费组时，Kafka 会在这些消费者之间分配消息。这意味着在这个消费组中的每个消费者只能处理自己分配到的消息，而不会重复处理。

    - **负载均衡**：如果你有多个实例的应用程序运行并且它们都使用相同的 `groupId`，Kafka 将会自动在这些实例之间分配消息，从而实现负载均衡。

    - **消息确认**：同一消费组的消费者共同维护消息的偏移量（offset），这意味着当组内的某个消费者成功处理了消息后，偏移量会更新，其他消费者就不会再处理这些消息。

    - 在例子中，虽然两个监听器的 `groupId` 相同，但它们监听的是不同的主题（`topic1` 和 `topic2`），因此它们不会相互影响。 `topic1Listener` 处理来自 `topic1` 的消息，而 `topic2Listener` 处理来自 `topic2` 的消息。不过，它们共享相同的 `groupId` 并没有实际意义，因为它们不在同一个主题上工作。

28. 配置 transaction 的原因：如果一个消息发送失败，那么就会导致这个消息丢失。所以要配置 transaction，保证消息的可靠性。

## 03 Websocket

1. 全双工的通信，即客户端和服务端都可以发送消息（双边都在工作）。没有响应 请求的概念了。

2. 底层仍然是 TCP 协议。（一定要保证收到，会重发）（UDP 是不保证收到的，但是速度快）

3. 前端和后端都运行着 websocket 程序

4. 称为一个 websocket 的 endpoint，有统一定位符

5. 所以需要握手（即注册）。websocket 由握手和数据传输两部分组成。握手是基于 http 的，数据传输是基于 tcp 的。

6. 握手时，如果两个 key 能匹配上、即握手成功。

7. ws://是不加密的，wss://是加密的 443 端口。（ws+ssl）

8. 握手握上了、server 会专门为每一个客户端开一个 session。（server 端维护了一个 list）

9. session.getOpenSessions() 可以获取所有的 session 的 list （当规模大了之后，单纯的 for 循环会有性能问题）

10. ConcurrentLinkedQueue 是线程安全的 （注意要用）

11. 可以增加 websocket 的编码器和解码器，来处理消息的编码和解码

12. 前端要用一个 STOMP 的库

13. 下面的代码是一个简单的例子，即前端发送一个消息给后端，后端再把这个消息发送给前端。其中，`@MessageMapping("/hello")` 是前端发送消息的目标路径，`@SendTo("/topic/greetings")` 是后端发送消息的目标路径。

```java
@MessageMapping("/hello")
@SendTo("/topic/greetings")
```

14. 也可以设置 broker 代理。

15. ajax 通过 callback 函数来实现前端的异步通信。消息队列处理前端请求过多的问题（返回给前端订单已接受的响应）。（后端异步，如果是同步的话、数据在后端就直接丢掉了）。websocket 解决订单什么时候处理完的问题。（主动推回给前端）

16. 也不是什么都要用消息队列。比如 login（高优先级的任务）就不用消息队列。

17. service 下的应该是同一层逻辑，不然会有很多代码重复。
