## 16 Multi-Paxos, Raft & NewSQL Consistency across replicas

8. 后面讲的就是 raft 了

   - paxos 是 bottom-up 的（先保证单值）
   - raft 是 top-down 的（直接解决多个 log 一致的问题、不用先解决单值一致的问题）
   - raft 和 paxos 是等价的协议
   - 一个值被 majority 了、也会在 raft 里被改

9. raft 的分解：

   - Leader election
     - Select one server as the leader
     - Detect crashes, choose new leader
   - Log replication (normal operation)
     - Leader accepts commands from clients, append to its log
     - Leader replicates its log to other servers (overwrites inconsistencies)
   - Safety
     - Keep logs consistent
     - Only servers with up-to-date logs can become the leader

10. raft：通过状态机 RSM+log

    - 三种状态：leader、follower 和 candidate
    - Leader: handles all client interactions, log replication
      - Invariant achieved: At most 1 viable leader at a time
    - Follower: passive (only responds to incoming RPCs)
    - Candidate: used to elect a new leader
    - 所有 log 只能由 leader 能做（限制），每个 term 里面只有一个 leader，leader 挂了会选一个新的

11. raft 通过 heartbeat 来决定是否需要 election

    - 如果收到了大多数 server 的投票、就变成 leader
    - 每个 server 只能投一票
    - 也是有一个 term 号、和 paxos 里的 proposal 号类似
    - 如果没人赢、就重试

12. election 需要 saftey 和 liveness

    - liveness：有可能从 candidate 里面永远选不出：解决方法：用一个随机 timeout 的 heartbeat
    - 每台机器只需要记住 currentTerm 和 votedFor（对于 election）

13. Log entry = index, term, command （log[]）

    - commit 就是把 log 输入到 statemachine 里
    - crash 的时候会造成 log 不一样的问题
    - 所以有两步走：先把这个 log 变成大概率是一样的、然后在这些大概率是一样的 log 的里面去做 consistency

14. 它保证的是一个 prefix 的 coherence

    - 就是如果 prefix 一样的话、才 appendEntries
    - 如果 prefix 不一样的话、会由 leader 发起进行一个覆盖的操作
    - 如果有很多不一致、所以就会递归覆盖、就是全部覆盖
    - 所以会导致 majority 写了、还是最后被覆盖了

15. 如何保证一个 log 被 commit 之后不被 overwrite 呢？

    - 可以避免一个比较少的 log server 变成 leader（选 leader 的时候加限制就行了，要有最新的 term 和 index 数，先按照 term 比、再按照 index 比）
    - 但是 ppt 上有一个例子、就是会覆盖掉 majority 的值，但是也有解决方法

## 17 Introduction to Network

1.  OSI, TCP/IP & Protocol Stack

    - OSI 有 7 层
    - TCP/IP 有 4 层（最常用）
    - CSE 只 care 3 层

2.  Layers in Network

    1. Application

    - Can be thought of as a fourth layer
    - Not part of the network

    2. End-to-end layer

    - Everything else required to provide a comfortable application interface （解决数据传输出问题的问题）

    3. Network layer

    - Forwarding data through intermediate points to the place it is wanted (找节点的邻居，怎么找到一条线连接到目标节点)

    4. Link layer

    - Moving data directly from one point to another （两个节点直接相连）

3.  更关注的是速度，不保证发出的包一定能收到

4.  因为这个包的数据是往前增长的、所以会用 socket buffer 预留前面的空间

5.  transport layer

    - 为了建立多个连接、所以会有 port（共 65535 个）
    - 握手的时候的 seq number 是根据直到当前发的数据决定的、所以可以防止第三方进入

6.  The Link Layer

    The bottom-most layer of the three layers
    Purpose: moving data directly from one physical location to another

    1. Physical transmission
    2. Multiplexing the link
    3. Framing bits & bit sequences
    4. Detecting transmission errors
    5. Providing a useful interface to the up layer

7.  传输数据的方法：

    1. 用 shared clock，时钟上升沿的时候就去数据线上读数据（但是需要很精确，容错空间小、数据的周期也需要和时钟一样）（只在 cpu 内部这么传）
    2. 不用 shared clock、可以用异步传输（ppt 过程，一开始 ready 和 ack 是 0）（不需要对表、而且采样不会出错、因为 ready 了才读数据）（缺点是 2Δt 才能传一个 bit）（解决方法：一次传 N 个 bit，parallel transmission）
    3. serial transmission（usb 使用）（有时候这个波形会变形，所以会需要使用压控震荡器，能恢复出信号对应的时钟周期）（问题在于有时候这个信号没有变化、所以需要编码）

8.  曼彻斯特编码：

    - 0 -> 01
    - 1 -> 10
    - 还有一个 8B10B 编码（8 bit -> 5 + 3 bit）（10 bit -> 6 + 4 bit）
    - 缺点：数据率只有 50%

9.  如何共享一个连接

    - Isochronous：对一条数据线分时复用（好处就是这个 8bit frame 是预留的）（坏处是这根线上只能有 703 个同时的 conversations，因为带宽有限）
    - 所以会有一个 multipexing/demultiplexing 的过程，可以把包放在一个 buffer queue 里面（单纯加内存不能解决问题、因为会导致等待的时间变长、然后就会 timeout、然后会重新发包、然后会导致时延变长）（所以丢包是一个好的选择）
    - 还有一个 Frame and Packet: Asynchronous Link 的方法，用发包的方式进行数据传输

10. 包头和包尾的作用：识别什么时候开始和结束一个 frame

    - Simple method
    - Choose a pattern of bits, e.g., 7 one-bits in a row, as a frame-separator
    - Bit stuffing: if data contains 6 ones in a row, then add an extra bit (0) （需要对数据做额外处理、如果数据里面有 6 个 1，就加一个 0）

11. Error Detection

    - 用一个 checksum 来检测错误
    - 最好也能够纠错：所以需要冗余
    - hamming distance：两个 bit 之间的距离（两个 bit 之间的差异的数量），可以通过 hamming distance + simple parity check 来监测错误
    - 4bit -> 7bit 中为什么要在 1，2，4 位上，因为这样就能够推出 3，5，6，7 位的错误的位置（为了电路设计）（不过错了两位就没办法了）

## 18 Network Layer All about routing

1. 网络传输中的所有数据不是同样重要的、比如包头信息会更重要

2. The Network Layer

   - Network attachment points 网络接入的节点（AP）
   - Network address
   - Source & destination

3. Managing the Forwarding Table: Routing

   - Static routing vs. adaptive routing 就是找到一条路线，而且要考虑到路线上面节点的状态

4. IP Route Table

   - 落在不同的网络段、就从哪个网络口出去
   - 里面存的是下一跳的地址+端口？

5. Control-plane VS. Data-plane

   - Control-plane：如何构造这张表（和性能相关度不是特别大，要求 adaptive 就可以了）
   - Data-plane：如何通过这张表去转发数据（性能相关度很大）

6. 每台路由器上的路由表都是不一样的，会更多关注 local 的节点

7. Distributed Routing: 3 Steps in General

   - Nodes learn about their neighbors via the HELLO protocol

   - Nodes learn about other reachable nodes via advertisements

   - Nodes determine the minimum-cost routes (of the routes they know about)

8. Two Types of Routing Protocol

   - link-state routing 一个是 flooding 所有的 neighbor 状态
   - Distance-vector Routing 第二个是只告诉 Nodes advertise to neighbors with their cost to all known nodes

9. W 是还没有处理过的节点

   - 然后讲了一下 link-state routing 就是用了 Dijkstra 算法去找最短路径
   - flood 对 failure 的容忍还是比较高的（因为是全都发）
   - 但是 flooding 的 overhead 很高、因为会充满这个邻居数据的包

10. Distance-vector Routing

    - 每个节点收到自己 neighbor 的 advertisement
    - A’s neighbors do not forward A’s advertisements; they do send advertisements of their own to A
    - 相当于 bellman-ford 算法
    - 但是对 failure 的容忍度不高、因为只是告诉邻居
    - limits 是 failure handling

11. 有一个 infinity 的概念、就是这个节点不可达的时候、会不停地给邻居发值、导致这个值变成无穷大

    - 通过 split horizon 的方法来解决这个问题，即这个节点不会把来自源的信息再发给源

12. 上面这个 Distance Vector 和 Link-State Summary 的方法都只适用于比较小的网络、因为会有很多的 overhead，怎么 scale 呢？

13. 3 Ways to Scale

    - Path-vector Routing

      Advertisements include the path, to better detect routing loops

    - Hierarchy of Routing

      Route between regions, and then within a region

    - Topological Addressing

      Assign addresses in contiguous blocks to make advertisements smaller

14. Path Vector Exchange

    - 网络中的每个节点都维护一个 path vector
    - 也是通过 advertising 进行更新

15. 这里的例子是关于站在 G 节点的视角的

    - 通过 path vector 的方法、可以降低收敛的时间
    - 也提到了几个对 path vector 的问题的处理方法

16. 通过 region 的方法做 Hierarchical Address

    - 即相当于做 local 的 routing，然后再做 global 的 routing（层次结构）
    - 可以大大压缩路由表的大小
    - 但是缺点就是更加复杂了、而且需要把 region 和 ip（地址） 进行绑定了（因为需要通过 ip 快速定位到 region）
    - 也可以有很多层次的 region

17. Routing Hierarchy

    - 跨 region 的路由需要用到 BGP （Border Gateway Protocol）

18. Topological Addressing

    - 类似于掩码的逻辑 18.0.0.0/24（CIDR notation）
    - CIDR: Classless Inter Domain Routing
    - 就可以用一条去表达很多条
    - 为了 scale：所以要让路由表变小

19. 上面讲的都是 control-plane，下面讲的是 data-plane

20. data-plane 里面只需要考虑单机了

    - net_packet.destination != MY_NETWORK_ADDRESS 的话、才需要 link_send
    - 如果收到一个不是自己的包、那自己可能就是路由器（就需要把包转发啊）
    - 一共有四条路径：收包的时候、可能是自己的或者不是自己的、发包的时候、也可能是自己的或者不是自己的

21. forward 一个包的时候、需要做很多事情

    - 先查表
    - TTL：在网上能够通过多少个路由器转发、防止无限循环，如果 TTL 是 0 的话、就把这个包丢掉
    - 更新包的 checksum（因为要减少 TTL）（有专门的硬件进行加速）
    - 然后再转发

22. Data-plane Case Study: Intel's DPDK

    - 是 bypass 了 kernel
    - RX 和 TX 分别代表了收包和发包
    - 是通过轮询 hardware queue 的方式去做的、就没有 kernel 的介入（很快，没有中断）

23. RouteBricks

    - 用了很多个便宜的网卡机来代替了一个昂贵的路由器
    - 降低了成本

24. NAT (Network Address Translation)

    - 就是在发送的时候、把自己发出去的包的内网 ip + port 翻译成一个公网 ip （相当于是 router 的 ip）
    - 然后在接受的时候、再把这个公网 ip 翻译成内网 ip + port
    - 其实不太好、因为在网络层用到了不是网络层的 port 的信息、破坏了层和层之间的封装性
    - NAT 是有限个的，如果 10 个笔记本连一个路由器、最多每个分到十分之一个 NAT
    - 对于 IP-set，不能经过 NAT、因为是加密的
    - ftp 也不能经过 NAT（其实也破坏了封装性的设计）

## 19 End-to-end Layer Best-effort is not enough

1. 以太网 Ethernet

   - 需要监测一个人发包的时候没有其他人在发包

2. 发包的时候、拓扑结构有两大类

   - Hub：所有的包都会发给所有的人（广播）（意味着可以做监听）
   - Switch：会通过路径的调转，只会发给目标的人（不会广播）

3. 例子里的上面这些 block 都是 ip 地址、下面的 ethernet 是 mac 地址

   - 在 ip 层发的时候、也会在包头包含 ip 的 source 和 destination 的地址
   - 到 ethernet 层、通过 mac 地址进行传输（相当于在包头填了一个 mac 地址）
   - 但是会有一个现象、就是 mac 地址是可以重复的，所以会有不同的设备有同样的 mac 地址
   - 自己的 mac 地址也可以修改
   - 例子里面、如果要发包给 E、就要设置目标的 mac 地址为 15（E 的 mac 地址），然后设置目标的 ip 地址为 router K 的 ip、即 19，这样 K 才能收到这个包

4. layer mapping（arp cache）

   - 会在表里面存储 ip->mac 的映射
   - 上面的 routing table 是通过 hello protocol 和 advertisement 来更新的
   - 这里使用了 ARP 协议（Address Resolution Protocol）来解决当一个新加入网络的时候、如何找到这个新加入的设备的 ip 地址和 mac 地址的映射
   - 会通过广播的方式来找到这个映射（如果有人回应、就会更新这个表）（这里的表是存在哪个设备上？L 还是 E？这个存的 station 为啥是 19？）（貌似每个机器都会存一个 cache）
   - 这个表就像 cache 一样、会不断更新

5. RARP：Reverse ARP

   - 通过 mac 地址找 ip 地址

6. gateway 貌似就是 router 的意思，这里有一个例子

   - 在例子里面，会先填 target mac 为 gateway 的 mac
   - 然后根据 route table 修改接下来的包的 source 和 target 信息
   - 所以 link layer 通过修改 mac 地址来完成相邻节点的包的传输

7. 会有一个 arp spoofing 的攻击

   - 核心方法是 arp poisoning（本质上是对 arp 表的污染）
   - hacker 在没人问路的情况下广播很多消息，把正确的 ip-mac 映射关系给替换掉，然后这个包就被发到了 hacker 的机器上
   - 相当于 hacker 会变成一个中间人，可以看到所有的包（在不需要路由的场景下、hacker 把自己变成了一个路由器，就可以监听）

8. 如何防止 arp spoofing

   - 这个主要是因为协议问题、所以会比较难解决
   - 方法是：定期监听网络中的 arp 包的流量，然后发现有异常流量和数据的包的时候、就会发警告。但是没法根本性地解决。
   - 还有一个方法是：用静态的人为设定的 arp 表，但是这样的话、就会导致网络的可扩展性变差

9. 上面讲的都是网络层的问题，下面讲的是 end-to-end 层的问题

   - NAT 和 ARP 都是在网络层中会发生的变化

10. end-to-end 层

    - 因为 network layer 没有保证很多东西、所以需要 end-to-end 层根据不同的应用场景进行设计
    - TCP 的 flow control 是可以当数据发得太快的时候、控制发送的速度
    - 这里介绍了 UDP、TCP 和 RTP

11. end-to-end 考虑了 7 种问题

    - Assurance of at-least-once delivery
    - Assurance of at-most-once delivery
    - Assurance of data integrity
    - Assurance of stream order & closing of connections
    - Assurance of jitter control
    - Assurance of authenticity and privacy
    - Assurance of end-to-end performance
    - 最难的是第 7 个问题、performance 的问题

12. Assurance of At-least-once Delivery

    - 问题是：如何确定一个包丢失了
    - 可以通过 timeout 来确定（但是需要首先知道 RTT）
    - nonce：一个随机数、用来标记这个包是第几个包（网络中常用的方法）
    - Dilemma 是不知道是哪个阶段丢的包，可能是 ack 的时候或者是发送的时候丢的
    - Try limit times before returning error to app(方法即是每隔一段 timeout 就重新发一个 data 包)
    - 所以他不能保证 No assurance for no-duplication （就是有可能会重复发送）（at least once）

13. 怎么设置这个 timeout 呢？

    - 首先不能设置 fixed timer，因为没有要到时间就会轮询、然后轮询了之后就更要不到时间、因为会大量阻塞
    - 可以用一个 adaptive timer，比如说根据 RTT 来设置这个时间，或者根据指数增长的方式来设置这个时间
    - 当前 linux 的设置是通过一个不断更新的 avg（存在权重） 和 dev（标准差） 来进行设置的 timeout = avg + 4 \* dev（经验数据）
    - 还有一个是 nak，就是当收到几个包的时候，receiver 会告诉 sender 哪些包丢了，然后对方会重新发这个包，这样 sender 就不需要对每个包维护一个 timer 了、只需要 sender 维护一个全局的 timer
    - 只要 at least once、就要有 timer

14. SNTP 里面会有一个 go away 的设置、即如果超过了这个时间、就会让他不要再发包了

15. Assurance of At-most-once Delivery

    - 最基本的实现：receiver 收到一个 nonce 相同的包、就不处理
    - Maintains a table of nonce at the receiving side
    - 但是这样就会让这个 table 无限增长，导致搜索开销变大和 tombstones 的问题
    - 另一个方法：通过幂等操作来解决这个问题，允许多次处理同一个包（即一个操作多次执行和一次执行的效果是一样的）
    - 第三个方法：还可以设置一个最大的 sequence number、小于这个 number 的包就不接受、大于这个 number 的包就接受，但是这个 old nonce 也会变成一个 tomstone（但是要保证递增的、而且不会乱序出现）
    - 第四个方法：每次用不同的端口处理请求、但是旧的端口就会变成一个 tombstone

16. 实现 At-most-once 会比较难、需要更多的资源，而且 crash 了之后因为 table 在 cache 里、会丢失

17. Assurance of Data Integrity

    - 使用 checksum（但是还是有很小的概率，但是不用考虑）

18. Segments and Reassembly of Long Messages

    - 需要进行拆包
    - out of order 的时候、会有不同的方法解决这个问题（各有优劣）
    - 方法 1：只顺序接受包
    - 方法 2：等待顺序位置的包到了之后、再把这个包放到 buffer 里面
    - 方法 3：combine the two methods above
    - 方法 4：当发现一个包没收到的时候、主动返回去要这个包，发一个 NAK 的消息
    - 这个 buffer 是 os buffer，所以不能允许一个 app 的占用的 buffer 空间太大、如果 NAK causing duplicates，stop NAKs
    - TCP 基于 ACK 的重传，而不是 NAK （NAK 会快一点）

19. Assurance of Jitter Control

    - 相当于看视频的时候的提前缓冲，来避免卡顿，因为看到的是缓存好的，而新来的数据有快有慢地来是感受不到的

20. Assurance of Authenticity and Privacy

    - 加密：公钥私钥（非对称加密）

## 20 TCP Congestion Control & DNS

1.  End-to-end Performance

    - lock-step protocol:收到 ack 之后再发下一个包，但是问题就是、时延会变成一个瓶颈
    - 所以引入了 Multi-segment message，可以一次先发多个包（Overlapping Transmissions ）
    - 但是 Overlapping Transmissions 的时候、需要考虑丢包的时候怎么办
    - 性能由 receiver 收包的能力和网络带宽决定
    - 所以引入了 fixed window（这个 window 的大小是 receiver 给的，例子里是每次收发 3 个包）
    - 然后为了提升性能、引入了 sliding window（这个 window 会根据目前收发到了多少个包进行滑动）（就能缩短 receiver 的 idle 时间，减少浪费的带宽）

2.  有一个解决丢包的例子

    - 因为 2 号包丢了、所以不能滑到 3 号包的 window 那边
    - timeout 之后会重发 2 号包
    - 所以这个 TCP 解决丢包的方案是比较保守的、会等待 2 号包的 ack 回来之后、再继续发包

3.  Sliding Window Size 的大小需要合理进行设置

    - window size ≥ round-trip time（一个来回的时间） × bottleneck data rate（瓶颈的带宽）
    - 500KBps（receive） \* 70ms （RTT）
    - 但是单单根据这个公式得到的还是不准确的、因为其中可能还会有其他的瓶颈、如果传得太快、就会发送拥堵

4.  TCP Congestion Control

    - 需要既涉及到 network layer 也涉及到 end-to-end layer
    - 因为要排队、所以会需要把包存在队列里面，会存在网络资源的浪费

5.  所以为了 congestion control，也要控制 window size 的最大值

    - window size ≤ min(RTT x bottleneck data rate, Receiver buffer)
    - 但是 bottleneck data rate 是动态的、所以问题在于怎么找到这个值

6.  congestion control basic idea

    - Increase congestion window slowly
    - If no drops -> no congestion yet
    - If a drop occurs -> decrease congestion window quickly
    - 缓慢地增加、迅速地下降、很保守的方法

7.  有一个 AIMD 的方法（Additive Increase, Multiplicative Decrease）

    - Every RTT:
    - No drop: cwnd = cwnd + 1
    - A drop: cwnd = cwnd / 2

8.  但是有很多问题

    - 比如一开始的一段时间、速度巨慢
    - 解决方式：只有在第一阶段用指数的方式增长（slow start）
    - 这里 ppt 上有一个增长的示意图

9.  duplicate ack received 是实际中引入的、receiver 当很多时间没有收到一个包的时候、会重发一个已经发过的 ack、然后告诉 sender 快点发、这样主动地告知 sender 出问题了，就能标识网络问题

    - 然后如果有一段时间 expires stop sending 之后、会重新从头开始 slow start
    - 但是问题还是有、就是图像上会有区域的带宽没有充分利用
    - 所以有了 DC-TCP 这些改进的方法、比如说针对数据中心的场景进行使用（针对不同场景有不同优化）（数据中心带宽很高、而且网路情况很稳定）

10. AIMD Leads to Efficiency and Fairness

    - 就是会先都腰斩变成一半、然后再每个都加 1、然后最后会收敛到这个 y=x 的直线上面
    - 这样不断调整就会调整到中间的点

11. 为什么不用减法？因为就没法自动保证 fairness

12. 丢包不一定是由于 congestion 导致的、比如在不稳定的无线网里、由于信号导致的丢包、我们甚至应该加快发包速度

    - 所以传统的 TCP 直接应用在无线网上的时候、会导致恶性循环

13. 总结：Congestion window is adapted by the congestion control protocol to ensure efficiency and fairness

14. Domain Name Service

    - 需要从 host names 转换成 ip 地址（计算机通过 ip 访问）

15. 为什么不只用 ip

    - 首先不够用户友好
    - 其次 ip 是动态的、会进行变化

16. Questions on DNS

    - 一个 name 可以有多个 ip address（这样就可以选一个近的、就会更快）
    - 一个 ip 也可以有多个 name（这样就可以有多个域名指向一个 ip、比如说一个网站有多个域名）（server consolidation）
    - ip-name 的映射是动态的、可以变化（用户无感知）

17. Look-up Algorithm

    - 一开始是存在每个机器里的 txt 里、但是不能 scale
    - 所以就有了 DNS server，一开始叫做 BIND（Berkeley Internet Name Domain）

18. Distributing Responsibility

    - 需要对 name 域名进行结构化、做分层 hierarchy 的结构，然后按层去寻找

19. Name Servers

    - The root zone
      Maintained by ICANN, non-profit（仅负责一级域名）（数量不用特别多）
    - The ".com" zone
      Maintained by VeriSign, add for money
    - The ".sjtu.edu.cn" zone
      Maintained by SJTU

20. Context in DNS

    - Names in DNS are global (context-free)
      - A hostname means the same thing everywhere in DNS
    - Actually, it should be "ipads.se.sjtu.edu.cn."
      - A hostname is a list of domain names concatenated with dots
      - The root domain is unnamed, i.e., "." + blank

21. Fault Tolerant

    - Each zone can have multiple name servers
      - A delegation usually contains a list of name servers
      - If one name server is down, others can be used

22. 可以指定地绑定和搭建 dns

    - 通过修改 hosts 文件
    - 设置/etc/resolv.conf，指定 dns server，如果找到了对应的、就直接从这个 dns server 里返回、如果没有找到、就会去找其他的 dns server
    - 好处是什么呢？既可以自己主动地去改动一些指定的域名、也可以在小范围内增强对域名访问的控制力

23. recursion 的方式的通信性能会更好一点、因为服务器之间的网络稳定、性能会更好

    - 但是要求就是对 root 的要求太高了
    - 而且是需要服务器维护有状态的
    - 如果 non-recursion、就不需要维护状态
    - 实际中如何利用他们两个的优点呢？
    - 可以使用 caching

24. caching

    - DNS clients and name servers keep a cache of names

      - Your browser will not do two look-ups for one address(就不用每次都去找一次 dns server 了)
      - 电脑上自己也会有 cache

    - Cache has expire time limit

      - Controlled by a time-to-live parameter in the response itself
      - E.g., SJTU sets the TTL of www.sjtu.edu.cn to 24h

    - TTL (Time To Live)

      - Long TTL VS. short TTL
      - 如果太长了、就会体验到错误（比如服务器迁移更新了）

25. 找第一个的地址的时候会比较麻烦、因为还没上网、所以需要口口相传

26. Comparing Hostname & Filename

    - File-name and host-name are hierarchical; inode num and IP addr. are plane

    - They are both not a part of the object

      - File-name is not a part of a file (stored in directory)
      - Host-name is not a part of a website (stored on name server)

    - Name and value binding

      - File: 1-name -> N-values (no，没有意义); N-name -> 1-value (yes，hard link)
      - DNS: 1-name -> N-values (yes，加速和容错); N-name -> 1-value (yes，website consolidation，服务器聚合)

27. 貌似最后还讲了一点东西，dns 就是类似于 metadata server，单机的时候会有瓶颈、所以可以扩展几个 dns server，然后通过负载均衡的方式来进行访问

## 21 P2P Network

1. Good Points on DNS Design

   - Global names (assuming same root servers)
     - No need to specific a context
     - DNS has no trouble generating unique names
     - The name can also be user-friendly
   - Scalable in performance
     - Simplicity: look-up is simple and can be done by a PC
     - Caching: reduce number of total queries
     - Delegation: many name severs handle lookups
   - Scalable in management
     - Each zone makes its own policy decision on binding
     - Hierarchy is great here
   - Fault tolerant
     - If one name server breaks, other will still work
     - Duplicated name server for a same zone

2. Bad Points on DNS Design

   - Policy
     - Who should control the root zone, .com zone, etc.? Governments?
   - Significant load on root servers
     - Many DNS clients starts by talking to root server
     - Many queries for non-existent names, becomes a DoS attack
   - Security
     - How does a client know if the response is correct?
     - How does VeriSign know "change Amazon.com IP" is legal?

3. 怎么解决域名服务器逐层 cache miss 的问题（转化为 DoS 攻击）

   - 用分层定时扩散域名的方式（定时获取）

4. Security：使用证书机制保证安全

5. Naming for Modularity

   - Retrieval（检索）
   - Sharing
   - Hiding
   - User-friendly identifiers
   - Indirection:与实际位置解耦

6. 比如：EAX - 是一个寄存器的名字

   - 所有机器上都有 EAX，而且叫这个名字的寄存器有很多个（实际映射到很多不同个的隐藏的寄存器上）
   - 所以可以并发地去做一些操作

7. 或者 phone number 的虚拟号码、也是保护隐私

8. naming model 里的 context 有些是 global 的、有些是 local 的，比如针对说一块磁盘（这张图很好）

9. bind 和 unbind，unbind 做得不好

10. recursive lookup 是递归的，multiple lookup 是平行的

11. FAQ of Naming Scheme

    - What is the syntax of names? 比如说网址里的.分隔符
    - What are the possible value?
    - What context is used to resolve names?
    - Who specifies the context?
    - Is a particular name global (context-free) or local?

12. 这里说的 5-4-5 范式是什么意思？

13. content distribution

    - 相当于就是分布式的 cache，比如把视频主动推送到 sjtu 的服务器上、然后避免对主视频服务器的多次访问

14. content distribution network（CDN）

    - Network of computers that replicate content across the Internet

      - Bringing content closer to requests
      - End users only use local (not shared) network capacity

    - Content providers actively pushes data into the network

      - Improve performance and reduce costs

15. 访问时在选择目标服务器的时候

    - 一开始是通过 http 重定向在进行，但是这样会有很多的 overhead（额外的 round trips）
    - 然后是通过 dns 来选择、是选择最近的（避免了 redirect）（缺点是通过 ip adress 来找这个 dns 服务器，但是不一定是最快）
    - 然后演化成了 akamai 的形式、逐层地找 dns、直到找到最近的 cdn 服务器，最后从最近的 akamai 服务器获取内容数据
    - cdn 提供商会从 content provider 主动获取数据、然后再 cdn 的服务器上缓存，然后再把内容数据发送到对应的 end user 的机器上
    - 用户一定是从 cdn 上获取的内容、而不是从 content provider 上获取的
    - 好处是减少了带宽成本

16. P2P

    - 中心化的基础设施会有一些缺点：比如说单点故障、性能瓶颈
    - P2P 是一种去中心化的方式，没有中心化的节点

17. BitTorrent 有三个角色

    - Tracker：What peer serves which parts of a file
    - Seeder: Own the whole file
    - Peer: Turn a seeder once has 100% of a file (有一部分文件、100%文件的时候就变成了 seeder)

18. 首先会需要把 .torrent file 发到一个中心化的 web server 上（根节点，公共知道的地方）

    - URL of tracker, file name, length, SHA1s of data blocks (64-512Kbyte)
    - Tracker
      - Organizes a swarm of peers (who has what block?)
    - Seeder posts the URL for .torrent with tracker
      - Seeder must have complete copy of file
    - Peer asks tracker for list of peers to download from
      - Tracker returns list with random selection of peers
    - Peers contact peers to learn what parts of the file they have etc.
      - Download from other peers

19. 这个去中心化建立在中心化的基础上（traker）

20. 这个 bitTorrent 有不同的下载策略

    - Random
    - Rarest first
    - Strict
    - Parallel

21. bitTorrent 的缺点就是 rely on tracker

22. 所以引入了一个 DHT: Distributed hash table

    - 即在分布式下的 hash table

23. Chord IDs

    - SHA-1 is a hash function
    - Key identifier = SHA-1(key)
    - Node identifier = SHA-1(IP address)
    - 这个 key id 和 node id 是在同一个 id space

24. Consistent Hashing

    - 就是这个 node 对应负责小于等于这个 node id 的 key
    - lookup 的时候、node 会一个一个往前、然后直到找到一个 node 能够负责这个 key（O（n））
    - 然后可以用一个"Finger Table" 的优化、让这个查找更快（二分），然后每个节点也不需要保存所有的邻居节点、只需要保存比较少的邻居节点 O（log（n））
    - 如果有 failure 之后，会有一个问题：就算例子里的 K90 其实最后是保存在 N113 里的，但是 N120 不知道，所以会从 N120 继续往后找（相当于跳过了 N113，就找不到 K90 了）
    - 这时候最简单的方法就是顺序，所以解决方法是合二为一（同时维护 finger table 和 successer lists）

25. 这个初始化的例子里、新加入节点之后、原来节点里的内容也不用删除，因为查找对应 key 的时候自己的负载也不会变大

26. 做负载均衡的时候、可以引入虚拟节点的概念、然后和实际节点做映射

## 22 The distributed (and parallel) programming: it’s all about scalability

1. 怎么去加快计算呢，方法就是 Parallelism

2. 一开始是硬件上的 pipeline，但是单核上的频率有瓶颈、因为超标量和主频的提升会停滞。所以第一个方法变成了多核

3. 在多核情况下、会有一个 Cache coherence protocols，保证内存的一致性

   - 一个是 Snoop-based cache，还有一个方法是用一个来统一

4. 但是问题是不能 scaling、因为会涉及到要 snoop 很多个核（gpu 是没有 cache coherence 的）

5. 第二个方法是通过加更多个 alu 单元（本质区别是和更多的硬件空间留给了 alu）

6. New ISA: SIMD processing：用了 SIMD 之后、需要额外写很多代码

   - 每次可以做 8 个 4bit 操作
   - why not 8X faster? 因为不仅仅是做计算、还需要做访存（访存速度没有那么快）

7. 访存有两个限制

   - 一个是访存的延迟
   - 一个是访存的带宽
   - Both factors matters ，取决于实际应用的场景和需求

8. 优化之后、cpu 的性能就受制于访存上了
