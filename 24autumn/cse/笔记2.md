## 16 Multi-Paxos, Raft & NewSQL Consistency across replicas

8. 后面讲的就是 raft 了

   - paxos 是 bottom-up 的（先保证单值）
   - raft 是 top-down 的（直接解决多个 log 一致的问题、不用先解决单值一致的问题）
   - raft 和 paxos 是等价的协议
   - 一个值被 majority 了、也会在 raft 里被改

9. raft 的分解：

   - Leader election
     - Select one server as the leader
     - Detect crashes, choose new leader
   - Log replication (normal operation)
     - Leader accepts commands from clients, append to its log
     - Leader replicates its log to other servers (overwrites inconsistencies)
   - Safety
     - Keep logs consistent
     - Only servers with up-to-date logs can become the leader

10. raft：通过状态机 RSM+log

    - 三种状态：leader、follower 和 candidate
    - Leader: handles all client interactions, log replication
      - Invariant achieved: At most 1 viable leader at a time
    - Follower: passive (only responds to incoming RPCs)
    - Candidate: used to elect a new leader
    - 所有 log 只能由 leader 能做（限制），每个 term 里面只有一个 leader，leader 挂了会选一个新的

11. raft 通过 heartbeat 来决定是否需要 election

    - 如果收到了大多数 server 的投票、就变成 leader
    - 每个 server 只能投一票
    - 也是有一个 term 号、和 paxos 里的 proposal 号类似
    - 如果没人赢、就重试

12. election 需要 saftey 和 liveness

    - liveness：有可能从 candidate 里面永远选不出：解决方法：用一个随机 timeout 的 heartbeat
    - 每台机器只需要记住 currentTerm 和 votedFor（对于 election）

13. Log entry = index, term, command （log[]）

    - commit 就是把 log 输入到 statemachine 里
    - crash 的时候会造成 log 不一样的问题
    - 所以有两步走：先把这个 log 变成大概率是一样的、然后在这些大概率是一样的 log 的里面去做 consistency

14. 它保证的是一个 prefix 的 coherence

    - 就是如果 prefix 一样的话、才 appendEntries
    - 如果 prefix 不一样的话、会由 leader 发起进行一个覆盖的操作
    - 如果有很多不一致、所以就会递归覆盖、就是全部覆盖
    - 所以会导致 majority 写了、还是最后被覆盖了

15. 如何保证一个 log 被 commit 之后不被 overwrite 呢？

    - 可以避免一个比较少的 log server 变成 leader（选 leader 的时候加限制就行了，要有最新的 term 和 index 数，先按照 term 比、再按照 index 比）
    - 但是 ppt 上有一个例子、就是会覆盖掉 majority 的值，但是也有解决方法
