## 16 Multi-Paxos, Raft & NewSQL Consistency across replicas

8. 后面讲的就是 raft 了

   - paxos 是 bottom-up 的（先保证单值）
   - raft 是 top-down 的（直接解决多个 log 一致的问题、不用先解决单值一致的问题）
   - raft 和 paxos 是等价的协议
   - 一个值被 majority 了、也会在 raft 里被改

9. raft 的分解：

   - Leader election
     - Select one server as the leader
     - Detect crashes, choose new leader
   - Log replication (normal operation)
     - Leader accepts commands from clients, append to its log
     - Leader replicates its log to other servers (overwrites inconsistencies)
   - Safety
     - Keep logs consistent
     - Only servers with up-to-date logs can become the leader

10. raft：通过状态机 RSM+log

    - 三种状态：leader、follower 和 candidate
    - Leader: handles all client interactions, log replication
      - Invariant achieved: At most 1 viable leader at a time
    - Follower: passive (only responds to incoming RPCs)
    - Candidate: used to elect a new leader
    - 所有 log 只能由 leader 能做（限制），每个 term 里面只有一个 leader，leader 挂了会选一个新的

11. raft 通过 heartbeat 来决定是否需要 election

    - 如果收到了大多数 server 的投票、就变成 leader
    - 每个 server 只能投一票
    - 也是有一个 term 号、和 paxos 里的 proposal 号类似
    - 如果没人赢、就重试

12. election 需要 saftey 和 liveness

    - liveness：有可能从 candidate 里面永远选不出：解决方法：用一个随机 timeout 的 heartbeat
    - 每台机器只需要记住 currentTerm 和 votedFor（对于 election）

13. Log entry = index, term, command （log[]）

    - commit 就是把 log 输入到 statemachine 里
    - crash 的时候会造成 log 不一样的问题
    - 所以有两步走：先把这个 log 变成大概率是一样的、然后在这些大概率是一样的 log 的里面去做 consistency

14. 它保证的是一个 prefix 的 coherence

    - 就是如果 prefix 一样的话、才 appendEntries
    - 如果 prefix 不一样的话、会由 leader 发起进行一个覆盖的操作
    - 如果有很多不一致、所以就会递归覆盖、就是全部覆盖
    - 所以会导致 majority 写了、还是最后被覆盖了

15. 如何保证一个 log 被 commit 之后不被 overwrite 呢？

    - 可以避免一个比较少的 log server 变成 leader（选 leader 的时候加限制就行了，要有最新的 term 和 index 数，先按照 term 比、再按照 index 比）
    - 但是 ppt 上有一个例子、就是会覆盖掉 majority 的值，但是也有解决方法

## 17 Introduction to Network

1.  OSI, TCP/IP & Protocol Stack

    - OSI 有 7 层
    - TCP/IP 有 4 层（最常用）
    - CSE 只 care 3 层

2.  Layers in Network

    1. Application

    - Can be thought of as a fourth layer
    - Not part of the network

    2. End-to-end layer

    - Everything else required to provide a comfortable application interface （解决数据传输出问题的问题）

    3. Network layer

    - Forwarding data through intermediate points to the place it is wanted (找节点的邻居，怎么找到一条线连接到目标节点)

    4. Link layer

    - Moving data directly from one point to another （两个节点直接相连）

3.  更关注的是速度，不保证发出的包一定能收到

4.  因为这个包的数据是往前增长的、所以会用 socket buffer 预留前面的空间

5.  transport layer

    - 为了建立多个连接、所以会有 port（共 65535 个）
    - 握手的时候的 seq number 是根据直到当前发的数据决定的、所以可以防止第三方进入

6.  The Link Layer

    The bottom-most layer of the three layers
    Purpose: moving data directly from one physical location to another

    1. Physical transmission
    2. Multiplexing the link
    3. Framing bits & bit sequences
    4. Detecting transmission errors
    5. Providing a useful interface to the up layer

7.  传输数据的方法：

    1. 用 shared clock，时钟上升沿的时候就去数据线上读数据（但是需要很精确，容错空间小、数据的周期也需要和时钟一样）（只在 cpu 内部这么传）
    2. 不用 shared clock、可以用异步传输（ppt 过程，一开始 ready 和 ack 是 0）（不需要对表、而且采样不会出错、因为 ready 了才读数据）（缺点是 2Δt 才能传一个 bit）（解决方法：一次传 N 个 bit，parallel transmission）
    3. serial transmission（usb 使用）（有时候这个波形会变形，所以会需要使用压控震荡器，能恢复出信号对应的时钟周期）（问题在于有时候这个信号没有变化、所以需要编码）

8.  曼彻斯特编码：

    - 0 -> 01
    - 1 -> 10
    - 还有一个 8B10B 编码（8 bit -> 5 + 3 bit）（10 bit -> 6 + 4 bit）
    - 缺点：数据率只有 50%

9.  如何共享一个连接

    - Isochronous：对一条数据线分时复用（好处就是这个 8bit frame 是预留的）（坏处是这根线上只能有 703 个同时的 conversations，因为带宽有限）
    - 所以会有一个 multipexing/demultiplexing 的过程，可以把包放在一个 buffer queue 里面（单纯加内存不能解决问题、因为会导致等待的时间变长、然后就会 timeout、然后会重新发包、然后会导致时延变长）（所以丢包是一个好的选择）
    - 还有一个 Frame and Packet: Asynchronous Link 的方法，用发包的方式进行数据传输

10. 包头和包尾的作用：识别什么时候开始和结束一个 frame

    - Simple method
    - Choose a pattern of bits, e.g., 7 one-bits in a row, as a frame-separator
    - Bit stuffing: if data contains 6 ones in a row, then add an extra bit (0) （需要对数据做额外处理、如果数据里面有 6 个 1，就加一个 0）

11. Error Detection

    - 用一个 checksum 来检测错误
    - 最好也能够纠错：所以需要冗余
    - hamming distance：两个 bit 之间的距离（两个 bit 之间的差异的数量），可以通过 hamming distance + simple parity check 来监测错误
    - 4bit -> 7bit 中为什么要在 1，2，4 位上，因为这样就能够推出 3，5，6，7 位的错误的位置（为了电路设计）（不过错了两位就没办法了）
